#!/usr/bin/env python3
# Encrypted with CyberEncrypt
# This file will decrypt and run the original project

import os
import sys
import base64
import zlib
import marshal
import importlib.util
import tempfile
import shutil
import atexit
import argparse
import time
import ctypes
import gc
import platform
import random
import threading
import traceback

# Try to import colorama for colored output
try:
    from colorama import init, Fore, Style
    init(autoreset=True)
    colorama_available = True
except ImportError:
    # Define dummy colorama classes if not available
    class DummyColorama:
        def __init__(self):
            for color in ["BLACK", "RED", "GREEN", "YELLOW", "BLUE", "MAGENTA", "CYAN", "WHITE"]:
                setattr(self, color, "")
    Fore = Style = DummyColorama()
    colorama_available = False

# Memory protection utilities
def secure_memory_clear(data):
    """Securely clear data from memory to prevent dumps"""
    if isinstance(data, str):
        # Convert string to bytes if needed
        data = data.encode()
    
    if isinstance(data, bytes):
        # Overwrite data with zeros
        length = len(data)
        zeroes = b"\x00" * length
        
        # For CPython bytes objects, we can try to access the internal buffer
        try:
            # Get a memory view and overwrite with zeros
            buffer = memoryview(data)
            buffer_obj = buffer.obj
            
            # Force overwrite for CPython
            if hasattr(buffer_obj, "replace"):
                buffer_obj.replace(zeroes)
        except Exception:
            pass  # Fallback if direct buffer access fails
    
    # Force garbage collection to ensure memory gets freed
    gc.collect()

# Anti-debugging utilities
def detect_debugger():
    """Check if the current process is being debugged"""
    is_debugged = False
    
    # Windows-specific debugger detection
    if platform.system() == "Windows":
        try:
            # Check IsDebuggerPresent Windows API
            is_debugged = ctypes.windll.kernel32.IsDebuggerPresent() != 0
            
            # Additional check with CheckRemoteDebuggerPresent
            if not is_debugged:
                h_process = ctypes.windll.kernel32.GetCurrentProcess()
                p_is_debugged = ctypes.c_bool()
                ctypes.windll.kernel32.CheckRemoteDebuggerPresent(h_process, ctypes.byref(p_is_debugged))
                is_debugged = p_is_debugged.value
        except Exception:
            pass
    
    # Unix-specific debugger detection (simplified)
    elif platform.system() in ["Linux", "Darwin"]:
        try:
            # Check if traceback depth is suspicious
            is_debugged = len(traceback.extract_stack()) > 10
        except Exception:
            pass
    
    # Generic Python debugger detection
    try:
        # Check for common debugging modules
        debuggers = ["pdb", "pydevd", "ipdb", "PyDebug"]
        for debugger in debuggers:
            if debugger in sys.modules:
                is_debugged = True
    except Exception:
        pass
    
    # Use timing as an additional detection method
    try:
        start_time = time.time()
        # Execute code that would be slow under a debugger
        for i in range(1000):
            pass
        end_time = time.time()
        
        # If execution is suspiciously slow, might be debugged
        if (end_time - start_time) > 0.01:  # Arbitrary threshold
            is_debugged = True
    except Exception:
        pass
        
    return is_debugged

def protect_runtime(key, password):
    """Set up runtime protections and anti-debugging measures"""
    # Start anti-debugging thread
    def anti_debug_monitor():
        while True:
            try:
                if detect_debugger():
                    # If debugger detected, corrupt memory or exit
                    print(f"{Fore.RED}Runtime security violation detected. Terminating...{Style.RESET_ALL}")
                    # Corrupt sensitive data in memory
                    secure_memory_clear(key)
                    secure_memory_clear(password)
                    sys.exit(1)
                # Random sleep to make timing attacks harder
                time.sleep(random.uniform(1.0, 3.0))
            except Exception:
                pass
    
    # Start the anti-debugging monitor in a daemon thread
    thread = threading.Thread(target=anti_debug_monitor, daemon=True)
    thread.start()
    
    # Return a reference so it doesn't get garbage collected
    return thread

# Banner
banner = r"""
  ______      __             _____                             _   
 / ____/_  __/ /_  ___  ____/ ___/____  ____________  ______  / /_ 
/ /   / / / / __ \/ _ \/ ___\__ \/ __ \/ ___/ ___/ / / / __ \/ __/
/ /___/ /_/ / /_/ /  __/ /  ___/ / /_/ / /__/ /  / /_/ / /_/ / /_  
\____/\__, /_.___/\___/_/  /____/ .___/\___/_/   \__, / .___/\__/  
     /____/                    /_/              /____/_/           
                                                                    
        [+] Encrypted with CyberEncrypt
        [+] Running decrypted project...
"""

# Encrypted data (obfuscated)
_0x53a8c2b = "PmCPOfSVG8L4HexukgNHzw=="
_0xe72fd19 = "Z0FBQUFBQm9JaEZES3FQWHU5MGwta2w3UnVvMlZCaWJHNHZmQ1RfSm10bHZIWGNTRUFyeUdCWWlfMnZZOTIxQ2ZHYVRTNTA5Z3pyS3piNi0wb3VNdlBNSDN2M2t1TWl2bTFoNklDZUV6ZkJmWHpCbkNHTDBnb3dMY3Z4MF80RGZXUGdqa1A0RTFVMVFNeXhvY3FYT053NW1jTUNyRzZESVpYVVhPd2V1QzRlUXlkeC1QcGNFTTluQW96bU10MmlCdnVtc0JRanFYN21ydExFaUI4NGttRkZ0Y0FacGZzMm11MlhQeXQxU0VVSmZiX2ZCWHBKa2xiUHVKNUhCVXNEZE9RTDNvbkNFTkVCQXllcjdHOUVOcFdSb3BMenhJbVp5MENnNGlZMmhPeXNLbHEzNDFuaDZTQkRFMTl5cVRreXkzS0JpTnZONElkSlM0T2o2bV92NmpZZW10MGNoSnQzYjJCeUZ0T1RHNWk3SllLcTN0VTZJMk5Gd3IxVXlCMXI1ZmRoY21QYm5OYVVveVNtUXJUdDgwekFwQ3QzdTQxc1liUGFudEtkcDdpUE9Oam1vSDR1UGUteDNvWGZCLVNpeS1RekszWUhfcGhvb3hPWXByTktzWGRiclB1TlgwT3FyeDJ3dENTM01SWEdsSVVCcVJQeTY2bDBlQlp2c3UwenFfT21yaUlzQXZwOVVjMGZjTkVKbUQ2dzc3aFFVUVJLakVpb1J5NnJhM1FYRnM5ZVc1NG1YZktBS0NuSjhQMC1jUk5WM1lSbnJaY0ZMZHppRElUVG1kVEt4YWRxdXhnUGVva3NQMUhKcm5kX3l0ZVBOUFB0Q1BxdFhTTnpXeVNROTZmMTNiZ3dEaERFOUV0SVJ5Wm1KaW1FSTZCdFVPZmZUUzJOdkcxR2FuRnlMcTVCNFdWZHB1YnA4MkNqNER3ZTRqY3hkYjJjTEhzSmFqNHZ0TVpNOGU2Q1FfV0taV2J3VG91bW9wQkNyZ2I0UUtKdnJFYnU2VW04VTFOVGVTUVBrclpjbUxMdHpqU2dhejZxNGdpQmNFd0EwVExIaVdvdGtTdXZGLXdKOWV5SjNnMWEyQXJoalYxQ0Q0dVlJUklUcU9ET29KY092QTZVZ3BLbUtkS0xCYmJtUVR2ZVN0bmU4TmVVOF82SUVUTjZmSG0yaHVUNnB1dm5ZM0M0OUF1SllJODhoVXh3bnNPU2hIOEx4UHZEemVzNGtRdDdtRmhsVEY3YUFDS0xMeUFJNE1lWVJJXzR4dTB1MVBBb1hJSDFwZE96MTFCX1hqbVA3QlBILUM0bFd3RF9LZmZ3NlMycmc2c05hdkZ0M2ZlbTU4QTBwY2tYZjJTRWQzQWNDVWFIZTdlbGN1TlRtQ1ptUFN4VHZXWFdjVUVsTVJhUmxCSl9SSU43NGhZRFJfX3VmSHlMM0lhS0FDU0NUWHZURngxYWRKN2VKbzBYalJaNHBNbTRjZngtU2owamNHdkZIZ3VzaW5YOGgzb2FTRDNHWV8zaVNiVkhWQ080ZW5xb0pLNUE5WWxnRXJHUm5XMy10RFpWckZOSTRHV3ZsS2lNb0llcU5XY0RINnRXTS1FZHNCN1o0ZXNQakNJRXF0Z1ZDY01JdEEzY2hwemx2Ynd2ZWd4QVNqNlg0b1cwTWNIdFVISjUtVmdGMjgtWDRScmI1bVEzTERJTzZtRGRGZm1KTW4xSkM0dVVjek1OVkdJaDY2MXVIOEN5Tm1NTF83OUpNUHlkeWZQYlQwNExheVdDOXBUUkVvWXNFSDZ3UzFyUFdZaUJxVUFRUHlhR1lQMUIzZ3BVWTlVNjRONXM0dHZJQ2dKWEVVeXF5UDBYNGYwNzMwZ29OUTJsUkczMFE4Um5fN2VvR05mMGVHSVNFWTRya0M2Rk5JMFl6TU5zUU9EVlFQVWxIRy1lTXhqM3pUV29FNEQ4ZXRkLUdQVWZwai1PdW9vbVpmNG1uZktaeE44cWtOYmJhbklJQ1VoY0xROUNwcUR5VWVLNnFzOFc1a0ttQkRQcDQ3a3U2b1V6T0Z2aTBGZ19zMlFnSUVlOGlMd2EzN0c4aXRwSmttSnlnNEhQcXhOQm5TcWpxR3l1Ui04dDFtdFk2aTlxYTNQeVRTd3VaYmdic2JkVFk0NTlpRGs2d1ZEY2ZGMjZGa1pBRGJmYnRudHVtSFJJeUdZVkFMandFQ2p6N3ZzVGRTeXVyeHJEOUt5Tm9YQVcyeU5fc0pTYjdjd0JjTXExWkVTTTNxVlgtYk5xczlFTDJncEwyaUlDaXZSU3VUTmg1REhyZnhLcmZGelJCczVQSjBJWm1pRUZEY2lWWG1rRE9Ddk9hYkpVMGxvT2xQQ3pjdGN2N2ttMFpJakpxUlRTU21qbXJWOTFtT04ySGRTSXdvQmNHYXJLVlpKTTk3eC12UHJxSEM4VEFVOXNNV2JlUkRPcHEyUWhLME9MNnFWQkdQR25rZmEyNVMxT0lUV0dWOXNXZEMzbzRRR0hkb1ladTdVLUllc1F3bjVYNE9UQTVqVlVaekdsZFgtd0Y4X0FmVTlfYk1kNXNTeHRLZXB2YXh6SG8wbWpmTFdlT1Z5MmUzM0paUXpzOXBvanZoNVhyVFdoRFRraUd2OGNOZkd6UWtDUTRJOXpUS0lNT0EyTmVLUmIxR21lRDJ5SC1uLTVudm94dHdiMnQwRnlZdkZaRXljQ3VJZ3pXSFV6RDItMC1wVm4xbDFKZGhzRk1yaHIzUTlnSXVzcVhRRFBJRjJoSzRqUmNhVzY1SVlySnBENGZDNWJxSmFnSDRCcFU4V0dYUzdTc2VFdTJKZEZMelBoRGl1QmhJcTZhWXFlMUpqQjBTQ0xrV3B1SHV2NkNGRWJsSVpkdk81NFpZS2hpSEY0dHhPQjdqN3BsZUp2NHFtcVFUcGFmMUNwMjBLazBSUHZLcmZiTXhwOVNVOWxseVBCZjBva0FQbGRpYWhWREtjZlhmMkR5dHNkbVBOalc3UmxWOU80LV9KRFE3RXg3b0F1TjhYSWZEMmRTb29zaDZrR3k0WVR1S2NKaHRmQ2VabVFoN0ZHd2Vvc1Y0QjVieWpaRmotQW9BdmdMb3JkRWlJcndyd1k2OWVtUGd2aGljVlJrRkllYmVDUXNPbXRGNTM1ZFZpV1Z5ZGdGQmFfVG1ucWlZb0VBT3FFOTN5ZmduVk5kekJ6ZDA4MHFDMnhfbDNDdnR2bzl5a3dxUDlUUWpBVzFLdFJrQlV6UEU5amlVM0JmWWFrUkNBMk5ieXctVEVhZ3FoMlJJeUhHdmY5ZUx5eVpVVTJqNVdubHN4TTdhMWFteXpSaXA4cXdaWEJEQW5YcE4zbUFScXVSMUlScEZiOGdLdjR5US1MeXQ3bmRQLTVSbHpNd1Z3NHpBX1hCR0RxdEVCVWJYeVRJNGpJeDJMdTRSNVVkZTBFcHFCREsyQzJnV3lZYTNFSkFpYk5XaXk2SXV4X2cxZE1vV0ZOM3plb3pMbWNtLS00MGROaUJNcnJMOGI2OVBDWTQ5M0RMSVVwcmgxSHN6cTBBZGJldy05T1htb0tmT01NdFV6c0o0dWZicmI4eVZxOWEzVi00OWk5M0djekg4eHc3STJEbkgwVU9fUkM0LUtYbW85aW5SX3psaTVZUi1QbHh0WXk3Sm1fUGwwYVJ1TjlnYUl3T3cxMDFzN1kxVHB6TU00Qkd4eklDMktoMmprRkV1dlRzR1l2Nzg1WG15U09GWjdOLWhUdzhKMFo3V3hsa29IS2tWZkJCRk5RamJ0bTg1Sk1ON3ZCanVTZ1JRYVg4aS14clBIaW40cF9zMmRSeHdFS2xGWHI5TlZZYXpFZ1MtOVV2Wnd3bGp1dk9vV3djamY1Y1FLNnhkc3l6cWtJUzBhNFY4MmlPRTlpVmVfUXVlamRGa2U1Z1VLVlZZTy1OV2lqZWZEeWtEakN6WkRYemVvTlBYUTMybHk2UjRxbG5mcmRZWWlzTTJWM3p0bjJUb0xZT1hyMzFKNWs3WFZ2LXd2RXhic25Ca0lQaU9jWUtPd0ZHOWx6V1p1azdwOUdIdDdiaUxpVkFnYzFMQkRoTjk5WVF5SjdiMU5yX3p5dnZuUkJBRU41cFZDbmlDcXZWbEplVkN0Uk9UTzQ4Y2YxazRFQ3VYWUdkX05sVXNpeHhDZDhidFJMeThUa2h4eUJTY0lPXzJnTzBrWTRhNVk2TjZ6Y0FsdlJzMDVjMWZKN1ppd2NBWUswT0NyY1lZa01DMEU3bFhMc21qMjR5d0xIY1lYQWkxdkp5Qlpad0lUblk2cEdHTzl1MmJvQXMzS0cxc2VhaWY5Tzc0N21kX2c4Vk8yd1psUUhGeGlaMEVzaVF0OFRlMHJ1RmprZ1VlajNJYWx2QlZfXzhvUE9mMUpfQnhNWWdPX0NOR09xQ3RCZDRzemtMcnZtbmlkZk9LOVlXb2xaaEZ5SFlpcHdLb3gwYVp1U0FrLW43TC1BQklHYW9vYWdUWFczSlhlc1lRdFRLQ2xDVFNTQTg3bFpwVUMtRTl5aFFmVTlQdU94ZUxlZ3Z5RVhJLVJTMmEwRThmQW5SUHZMN2trU2hFVmdNeW5jSkkyal94VElza0dydlpaTTFkOWVxV3F0THlMMjJRY3NHVFR6c0lSZDczdUhkUlkyRUtiVEoyUHBwdi1pU2N0cXJnbWdCcWdfN3ZfWkNFQnZDdHVkNjZyNHFvWkFJRDI2ZzhHTHJ3YjM4OXZsTENYdFU0Q0FzYnFXUnBFcVFpQzNvNEk5ZXFVUnZ1OXRvaDUtMFJLajdMcUotV05UR3dTc0poSWVvN1kxUzJQeWlrV3N5VnJZMWpTTVAxTE5NbFQ1cUpzdEpzbExVOFZpcVJIMkFmdUhTeVJmeTdudWdjU0dDRTlBVW1SVmpFU3RvdUc3Qkk3c0RrLXViaUFZUlpyRDJvaC0xVVQ5U0FoSVpMQm1KMmJRSU9hZDdROFRpSzZxS0c2Y1ZrMk9qNnR0OEZCZkVTdmNwbXVRUDJOV3hpZzhFbUV0MlBhSVVQdFNnVjBqdUY2NVFhRm51bW8yTUxjcUxzVlNyRDNwOWw3WDU3di1TSDZKSEFUQ1JhVGk2dlVyUVNHTXA2YjFZdExPRzI1THZzU2x1bWN2SzF0c1RNMTVDTHVzZ00yNHgtakxxTXJ5NEs4WU94cGlTWDNoTUlxRjNPV2lTa3JTRjJxWlVHN3lrdDk5a0lRM0lzQkxfdkpyZDVwUzNtODlKQXRlUEo3N0c4ZXNGTFFmbUM0MXE2Mlo1SDVNdERVWnlTdm5JbTBBd0N4emFnbzFWVTQzeVZzdUVzanFCLUFsZ2NINjBINHZyTmxWYXVXWm1OR3dMZUFzcjRXZGhwUnJZVTNPN2t2Y0NscVVSdzBoQ0Y1ZDhIUmIxOWloQlVwNTJIbXJ5aTd6aW94TFhXZjlOZDNTRVdzWDdxeVAzVGxvLWxnWVdvdmV4YlM5VTZNc0M5OWxyQldGOW9HSzQtSDVLSVFGb3phYzQ1X2NGdTdwbmlaMjBjTXdBUzRFMjZWS3JfeUxmSXJ0MFFYYkljRGZxX3VHSU90ejFWeTJTVXJSSFB2eHp6cDk4OE14djIwa1ExOERBbmlMcnRCLXV5aVRvMzZ1Q200U1puTUM1eGxrZmQ1czJYMngxa1ZZcE9TcUN2TnVIcWZBUlY0VkdULTZmZjZzTm1YeWxXMEhTaWlJWFBMaUNjUGJBMkFrT1p1ZFo2aGUzNDhGOGhDcXdOZmE1ZkEybVRHTFY5bUpnaFY2OURpYXBGZkpxTUJkNnRNQTNfamoxVm1mMWpvbkFUbUZFYjVSZUZZdFBRWFFRZ2JfTUNZUm5nbDRYN3ZGd1FhVjlETFk3NVg2Q0xFWTNoWk56enVyS2lpNFBNNGhoUTdjdnFDYzZPajlud0V3UzdudFpKSEI3aHpDQnZhcFpub3FBaktiLVV5UlRlbTNROXFSVER5dzBlY01OUUVfVkI1YUpkVGQzOEIyQmhHcVZuOE1Lc1lBaE5hYzFwYXE3OEtDNmJjaWswNlp5dzI1VlAyaXhZUlVzMzdiZ2tGeWVBdGUzdHdqeDhPVWVIdHdMSjR4NDNRNnJXVXNkTGJXMjJKMUtMLVNkRi1ib3lyc1NTNEdiSVZsUGNNaXNDU1BMM3l3U3FDOUlOMFBnc1Z6RzlKY2Q5Q1dhNVlCNXB4Xzg2QVNHMmJwRG9qMWtuY1JWLUxpTFYwWkRTeHpfOUVBY0U5aGNENVZLdHhZM2E3TTk3ZlFqMkMxLUlJcFp3aWhhRVpwbTJKMkVhUmNMVVE2bGZJWFlmS01pdVl6NUdZb1dRX0pEX2plWFo3dDBxcWx2S1Fyb3JiNF9UNWhLY2hDanl1X0dWRHZDTmo2T0JGV2U4UTlacVBDam5GbWc2bDhCeElhN2dNM1ZINlhiMGZuV2FqV01uMWNweUFmRm9xdkRFb3ZtSkp3WTRyVUtRNXJPU3RPdnlvU1BqUC1xc1llcHNkcmlCNXpkQUN0YTN3S3BZTGRxMHlqb3h3bnBieS00UHRFU09JVWdRX0ZyWGY5SjF1amNsTVJiZTdBeTA1QjRuZ2FoZWVOLWJfSWw1MlI4T3Q4YThtblJ1NlpZTWhnQ3VnM3RUTWdQUFh0N0FzaFllbGpIMlgwczNIS0FPM0Rscm5VUlFLLVBEdjRGcjE3VGU0c0ltWXQyUGpTQTdvRVVKeFM3cm90ODJWajFUTGI2R1RpX1J1QThxckU1YzFaS3QyNFRxMXNGc3NNMHkyOGdNNHpxWlRLQk9JTzByV2NoYmI1RDhfYzI0UFZhc0RxLV9NaHE2cEJmbjJpa0Rxc3YtQWVZR2xBaTFDSEk4U1lCUVVCMGlrNEhfbkJ3ZUhwX1cxdXJwNVJlb0hxc19LaVg0eUU3WlVFYWhVUnpTdkhqOHI2OW9ZODNxNmdKeDlCQ2dSQllSLUxTTTgwRHY0Tm9tS2lpY2VUTWxVYUhhRGdLMzNmZTk3RkRuTHNhMmdZbDFSR2FsZE5BTUJEakVlczZ2V3A1ZzlBTXVjLUdhUGFJc2tKeGd5c2lrWmRiTG5UakZoQjkzSmhHSUVFNFdjOEt6UGNheWJvcnR3bnkxWk9pQVhPZ2I4eFRIWjczTGpXTFNOOE9GUFNwVlJwU1pmbTMyRFZpXzJ5eFI2TXdjRno4MjdfcFdIcVNRSzE5Z1BjbHlmWHVjNUhFSVZRV1E4aXlEWGsxUVBzVGlXdlZiTmFDR0l3VDIzdlVDOS1qRGRQMGpfYWstWmJkaFhhcDhiWVFhZFgtUGtlbmdIOEhBSkJjRVNEWS1zcDRQcFo2RDJFZHhLNi1pdmFJYkcwcGNraUdBLUNSY3hrMDROaE9KVTFpQmdIR19NeHRlVmlHS2E5dmlPNDdKWFFkalZuUTdXY0FuVkN2dEVNMUs1dnE1cnM3Z1U2UEdHdkNrWlp2T2JmTkJlUXh1djRORU1TSnl6a1hCQ1dycHR5NmlZTGVZa2UxdGZ4MlFOak1FVDhHTC1MVGwtd25aTzJ5N3hsQ0xHUGluUmVLOGp2aE9zUU5NWmw4NDFOaXc0MFJwNlBWcFVSZ1JUdm9mNWZORWU2aW1JWFIwR0p6VTgyZkp0Tmp3TVhwMWVkWVBwVTdRMDVCUTlQSkpUWkZ4dnU3WFN3LXhxaE1IMjFYbTh3azdWdEZGM0lHYktrZkM5UUhZXy1ESEFTWDBNcGtsVGhyWUZEZ3pyYkU0WmlvR0ZPZ200emNkeS1ub0xwRFNkcnN4Y1ZjNHFMTkp2bERobkJHWHIyaUdoMzMyTGFNRWFUMEdzcU9GbUhaRGJVUHZSX1otbExuLWxac2pwWUpGbUl5MmR6QmdxVVNRRWpVVlNOVTNqNGhZbGt2Mkp0eVRvd2ZMa2ZWbnJHQmNrMWxPS0ZXaFZBT1R1RmUtYjR5MkpxRFlTOTJuMVhNdlFLdXRyZWpPa3ZzZ1JOd0NEdjFEMUdydEw0ZllLdDAxZzlJSUlZQzB3SkNLajk0RXpFU1U0bWsxcVdMVndCbEh5ek9uZkRWZS14UXUtSHJKb3Y2TE1IWUZDODRHV2syNUFUa3B4X1JKd05IM3lWeVZEc1JfbXdPOXlGMy1wOGhPQ0w2ek85OHR6a2xlQ2dYcVBfc053M2tYeFU1YzV1dmg0MlpDeXdHUzlQTXI1TXhBa0MyNmpIMzFxQXdoejlYYVlnbXFXRkd4ZFlCeDUxSUdsMzc5allNTFlhNWJJVkVla0dCZS1kLVNNZ3hYSWR3bVpfTExZeDBMRmQwZTNHZGNmeEh2eFBXV2lKNV80cS1zVGZTTEREY0FkZnZaRUc3Q2lfZGh5b3BHMkNyNEhmRnJ2VmpmZ2ZETlVQREktU2k4azBrYWtXN3dLREdjN3p5TVlxTkdTYVdpTmVBcG0tTURYb2VOWHdPR045MVRlTGo1OVByenc5SnAyd25CUWplaThsLTE5TUt0TC1HU09SdWhBMXBoVHlJQzNuVGQ4NjBVVW5PVl94emhtSDRuQmFrT1ZRRlhUTVhpVnF2QlpGdGRMZzhBR2x1WlNFS1RCTEFBZU5OYkxkVXg4MFVsLV9UbWRaR0hWUC1KSFp2TDZDam40dmRGTUVBWEFpcGpYUkM2b0ZKTDhReTJaU01RbDFHLW1CbUk0SWdFYUs2aVZKa25NeUZmZDJBQWlKMXlJQkFkT2VkMDItdjBGd2lyUU1SMFFENjk2LWNzLUtkQ05aaE9fd29ub1J5TnZraDR3V1JtbWs1ME5aVllrejMzVlg0bWJiMXNVYXoxazBQWlhoTXQ3NXlYRlBCaGN1Q2lhY1VjcFh2WTBoVmlkX2ZVVk85VVdYVXFqRVJSeFQ3TFNjcHd4VGxhWWpRRmpWZkoySVNFQXVvMm05QmhQVlBjMWpJb2ppSVEzaURmZ24zWjRWZ2htMXJGczJsV3U1S3VFaGY2eDZmQzFGdmR3d2x6YUo2TUhjVjVOakFwNEhvUlNSOTdFUkc2RmI0NEswVEExQUdZeTdJLXAxMVZIZFVGM2YyMDRJcTYtak5kNlY1UEt4VERrVmRBZEo2T0NHcjBOQlFRMTY1Tkx5di1MZzZNR3hZN015dUhDdjdPUjFJY1dlQzhyMWN3U2J5RGN2WXMwT3B0QWpnY2RaZE4xUHl2emVWWFJQQTV5aEdaMldfQWo2aVdlQWdTaGk1eDR0MnV2Wi01TktVcFNGWk5HX1puZWJjRFZ0SWQ1NnZkZ3NfbUpva2w3Qks3UXd1TktXaU9hdS05VTdmUXJremhsTmNYSUZ4c2ZmTnY3RmJWSXpTdXhXMktDVG1Bem00Ykc5VnhncEppZmFoODdrV1FvT1RYbzdpWkhYNjEwamw2bmRJNXE1R2Q1U1gyQ2JtVW1WZno1NkdMYTBSZjlKemRaakVHZWVCUE1BR3ZHWlRZZU9tN3BKLU84RHcwOWk0bnJ1ODNjRUl1Q200eFloVk9VekZGVXlsWThHb1h1SjdXX2ZUa1oxLTQyRE9GZE9qdVIyVmlqWHNhOFNaNHZQMmJLdGRPRzUwQU9yckhzMjRvbEUtNDI3Ml9aZzF6ZEpDeHBLSlEtY1FRdnl6cU1Ra00wSkp5ZGVhTUJGV1Bkazg1ZkF2RmFyYzFMUkZYOVlYb080Z3J4UWxTTHBXYmpSYWlORjNHTmZwcXlyd1ZoeGZJWU12dnFfYzVzZGpfdFo3MEdWT1ZGMUtuM05aSERkVE9HdlIwenRZMXhZaGpaUkFJY0gxUmx2RG12NjJPTFdFemlrSlVrcnhjOUF2dk9lTkJ5Nl9uX1pXTm5xeEFrRF9IZ2JqdDRxdmN1WDhBT09Zc1YtSWF0VFRidVlEUl9lSXZVbFRxeHNBZlJOX0g1cFBHdXJfSDJjSHp0SjFDX1lPd0Jjc214LVpmWkVVTUlvX2VVMmNHZUJwNnEwMEZjZDlPSXY3NDZrdHVDaGhEMDJVQWZzOGRaZTRCY1oyWEpLQWRYVDFtWG9NYThyNUdveFk3bnlfLUlqLTlQZjJnbnhpMk1SRE9OUkh3enZQalY3dE9kaWNYcWdJVVdqdThwMHdtYTFwc3FVdlRaMWxReUlMZEFxN216UjAyQTBxUVNkemJ6SjZ0OUUxNVVDTUJqWGZFT3d6LWpNdjEwMHd3Y09iMzlma0twNmFJOUZfM1l6MS1ubF9WNTV2RW1ubmtzc3Atang1UkFRcDRzUnpOR1ZoZkFfc0Ryal9VeVhYdnBTMXZUTE5hdGpNTWUycmkxRzVtbzg3X2EwQlJkelRwU244ZTNfc0xhN2lnZ3BqRXFSRGNxSTVISDN0czRaQ3BJdlBCekhnMC1ocE45cy02b25pTzZxNFpNVktPbHE4UmFiQnJIZVMxdmUzazZtQlg2VDdWNElVck1LWWxKQ3RNODZIbmJqdERuMkplV3JiUXdlYUtVR01EUlpmSllpd3dBMFZXZ0tQcGlKbWR2RzBTdHZ5NnpVWUladDIwQWZJVnM1cTBnY0VUdVMyNzhTUDFYZFlvN2VxQXdabEZRSzVBUHYxa1RJVkZ0X05FVVFicXkyblUwcWZKb3o0cGNNa1NUVUlSSmw5bjhrU05fRUw2SVNvaEktOFZuOWFsdVp0eTZpNm1qV2VWUlpDWjVxc1NBNWhOWHRTMWU0LWpNejZFd3d1cmRHTTI5LU96V0ZlNXY5Yk84ME9QZ3FJWXFqYUZEaDdPend0YjZ6ai1jOGZNTVJLYktTT05haHU2QzUzU3NFeUtPM1hLY0xuR1NFc1NrUUpWSnIzdVE0QW5ieDNfWXhXUXB5TnpWT3N6UXA2eGdvWlNCT0FUWkpEQkVTMDkxTHFpeW1oZnZMSjJWSnh2UXE0QXBQTVhCeGlDNzhORXdzZXpPbVFvU3E4LUdtLXI0WDZlcThxd0JSYkI1Nk5XQVpSMHoxRTA2UHJvNE9TWDZ3Vl93QmdaQzl0NUhpZ3BRb01RWG9MMGJwVEY0M09zQ0dZYkdZZC1FZXVkTW1XV21UVTBYeDg2bVJxNktBalFqck1xckktQTNEcko1RXZKU3NBRThqSFZtZXRmVVNJci1FMlFjUndGeDVJTTFUN3dBdWR5VG9tNjRfN0lyUWpWNkZDTzVDdE84OW9vT0pRTEVQdXAwQ0hvVXhQYkVIenNodkRPdjdDRmd4UDhQUDVVS19fcDFHWGRoZ29xbWRRa3ptV1UwNmNsT2hkWnhfeFdkb3NmTV9TbzNGazQwcUk5XzFQSGs4V3J0aHh1a3MyOVlkdkxSMjNMWTRYNEtLcm9fWE56QXM0YVdzcnRJa1JJbmhZVGNHdkgwdXhRVzVyVnlfcTY1TG12T1Zud08zX1dqN2FzNm0zb1FjM0dCTFJvVjd5cjlDdndaYm1rUVg3RUxGcXJaQm9zcVlfZUl3Z1ZBQ1ZuS1dKYVFSRElwZlEzQ09vUk1wSkpQQlZTY0N4WkRMWmpGeVZGYlZoZmVNQ2I4RkhwVkM4Nm9aWDliSnQtYldSZHB5aTZ1b3BHSTZFYTdnb1Frb3BIRHEyd2thX0l6YU9xMmdsT29JNjZkT1Bnc3d6VDRWYkl4eE5sYUU1WWRDamtvRDhONV96Qm5mcExCbV9aNVNXNnBBSVRMN2NEdzgyVXpVbllvR19NWXFWUENxaExMdmI0WUREaU1hd09uVFVWWmM2WTIyU21wUGJyQkotRTduWlZhcURPWERZa1hCT0ZHcDh6VGdrOWNUMy1sNnlsR252akxYVktVRERONGpvUkxhZVFDT2JaYlZEYlBfTU5LQ3hZUHNUdURXS0FLaTBORFo1ZDQ2eTA5UldlUndCakxzNW92d05NcThHeEdsdmluRks3SlhxckVLelAtaVBaeTBaa1lCLVBIbi1WREltUXBHSTByc3dXS0F1dmRDSHQxOTliUWpBOG1rcXQwQ0tpR3hSdmxFbUFJU3ByLXlrdUsxYU9uVU41MDNGZVhxTzMyb1JRd3Z5dTJmN21ZY2lUeDl4Z0xYVVM5ZkJUN21QdG1xbS02eFotZ0cxWU5IRHcweGFvTUlRc0RBMkdMMlJ1VUZOelNSTnhtcm5EeW42YUFGak1MekJUeWJTSmtUamRmZ2JQR2c4VGVHMW94cmV6WUIyZWdwVjlLd0c5VzUxOHljWmM2MnJxcHJmTUswNkQyLXBiNWgzZW9oaXUyaWxPNl9xT3FRT1g1WVRJMFlYS2hjZHN6ckRLVjJNbmRHU0lHTXZSQ21Udm1PcTB1RUhNYmROZHBieEVCbHAtclpfT05xRDRFV2xiMmJsejQ1ZGhCOGl6UDZtQ1NVQld2b1k5ODRtRVBNS25hT1BKYnl5NlkyanFtV3FMSVVHelVmcWVzdERCcGU3MFNWT3RKeFNLUDlueHBVcU9FRWFleHdES0NoSnJ4VmlnR1pkQ0wyQzVkQVJnaWFFcjZDZVM2T1dZZmdBZVkwQm1ZVGZrNzIxRFZqZmtqb3lVaGR2aG40WVpkTlN6b2RPcUJBcjNlWkcxZ0toTmpnVDJtajJKa2Z2bTVzbUcyTzZDc1ZtTHZqM1YwcnR5ZlRnMXNNVnY4ZFlSVC01R2RVd1VzSUFFeHJYeklGZUFEOVM4Vk1XVlBCeWdHTXdVb0gwaWtTUWJVMURLYldJejVaWGIxdkJlTVBVNjg3QUdjUGNMMnNNTlhuQzBNTlB3RTA4M1BLNjZyeTZTWGthbUYtVUx1dDBscmVnSlVUMzlNX1BZbjdxN1V2N1IzUGhKaEtNNFhMQkJQMTVNQU5BSWJGWUpoQVlldnlkNllXdU84YXZncGV1UVBpcktZQzg4S0lmVjhwNW5lSjdMMjNnaWtnZmFlS1E1VnFPZ29EcUpTTENITW5KMVg0MFRodWowdmFIVE9KcFd3MkF5U3B0N2xwanN3anJhODVXeG9GUF9UZF9ZOEJiMURGaU9CVzdhZlJ5Zm9zUFNtUU1US1NBS2wxbXdOaFRHYjV2YVhWVUx3VU1mTVA4ZUpVNmpqWUVqa1l4RHNDelV0d3d4Q2gxYS1pMkRzbXlxWVRBamk1Q01MTlloc1RNbEZocDV5ZDNZSHdoRVVZaDFqdW43QmhPUXp6YmlHV0hTU3BISEZsUlU3QkNUcFhPcWxXZUE2V1l1V0UtVUZuTmFMWjNjMlkweE9CUEM2Uml3dWNkQ2t4ZzlVNmZ2S25acTdhcEpOMkdpYzJCMUVfQTA1bXVKaVBOVGtuN0NqUGxrVTNjM18yVW4zM0Y1dnlEXzhkUU1QRDN6RzFwejQ0d25ocHY4amJ0alpBZkhlRy00ZTVKbjVjMUkydWUweGdVWlNRVW1VWVl0bFVlaS0ybUJNNFNOVTZNUkE0SEUzYy1WNThSXzFIbWstZFpPS0lRMW1KbTFLVU1mWlYxMVNIN25mR1h1eGdoTEVWZDQwRjlpVWtGcU5FME9XN2MtZ3Z4c2g2RkZudVZ6cUk3ZGtTNllvY3gzX3NSdlFsdHBaUVBEczJFSnNzMW9maGp2MFZkc3BoTTNVMzZVRGN6c3NZQmc0Wi1wOTdDSEFSS3dPOXduLWZwTE5UZmY4eG9GVjVVS1VnT1hNQ19jU0MzU1BHZUlQYmJxVnp6OE9LS1FXNElIX0QxZzUxaUlHZzczbkwxc3NlSEloTk5BbWptTU40WlhzY0thd1VXekpic3diaWxHSS1kYW5PRXFKMHdRbFBaY1NwU3JlVHEwLU1DOFhFcnhqZHgzcjU5UzZrNmtjZmxaaXBqUkluTS1DM29mekJfdkJJb1dhQkJxdEJ4OVA4N01aZG8zdTg1azNma1AtbExiZGFnQWJDdWJPbEM1Wk81V3dwZExaRXlhWE9MLWl0SXZkcDRMc0V6Vkh1R3k2dks4bDN2aWNMQ05MM0h0ak56TTVVaHNGdzQxQ1NlSkpnUC10ZHBoekpWVWlES0l3VlFIUnZhZjVWLUJOa2V4azRtVHNHQjhfSkMzN1VJdkVwZ0xMdHVBOFVNU1pFWDl6anRZMFkxRjh1eEN2QzRnNDVDdmJId0dDcHdIM1pIWHB1Rk5mdk5Gc1k5WWVBQlR5NlJEc1hnS25kX3VuMk1kbE5rdENTMTlJSzBsNVJGcHlFWWlweFFHVTdsc2kwQzRmVTBlWlJRaEFGQm93WEJ1aXFLR3JlbEdtU1ZENnNURVpLQ05MRnNFZFFVendqMnVhZlF1dFpEajczRWsybzRmR0FaUEt0N2p0QndoN0JWZnRZMThxdFZYNUVrNUtrckZ0VVhsTW83QkZzclF4bktzeU9Dc2xHcjk0MzdGazBXSXZnNHg1dU1kSU1tQzcwYnMzakwzTWhmOTk3anF3QTBQVVFhYVRhbmFQS3ZVY2J1YnBLQzBlaGdxQzdBQmI2SnA2azFjWkpBZWRhaTFZMTh0T3JKSHJYUmVMaUJ6U2NVeEtxaC1ZRndjQkxPOWxZV1FoN0JyQ1hxY3VwVnpEUk1sUUVkbnNQRnhleDdZbTBnd1FMVFdnc0dNM0lySjNVMXUxSzh4WHMxeEQ3bERlMHpCMElmNGxPSXZ2c05zLUJ5NTNvaWVzMmVGMS0xazFsWlFCejM4VFVpYm8zOXhQVEtfY1pOV3FaZV9neGl5dldPUHlkMTdrMDNEWThRczhubzVkREVmYUw5NTU3cmsyUURwOXd1TzBkMko3eDlSZHhzeFFkWjJRVmowRUtxM3RlRzUwWlpVdmRWS1lFbEx4blZZYUpTVXJkTVV2bEQ4aFlnRG1hRE5IYVlmODZZS255S0NLdkxHbkNfT3k4YU1JV3NUTlloNkMxbENfQzl5UUxHb0lDZXNhcHFJVi1KQkwzN0I5NnNWMkNkckIyemcxREE2QklYbVZYeG9GQTZueXlpVHJiVW9IM3prTWMtZnVSWVdTZ2ZIV3RiWFQtd3M0dDliSWhLOHhRVnJiZ3JQbW5MNERwZzlkNkhzQ2hNZWNDYVVJLWFVZHQzY3JsZzZkbjR5bzZnMlRES2ttOUd0Y3RrUFRvcFVhSXFyU2xpUUNJN3hkUXJwLXlEQWdLOEN4SDNyN1NhQkpoVThSMkdNdl8tSmpjdWJ4Q3B1NmVwUU1vT2ZFVWtreEF2R3llbWxYbGFKajNuM2tsMC1SRFZQaDhWT292TkdmRWlNVUlMU3FSUENMTmVTWlBSR0tKMGV6ZHVtb2xkRWtMUklzeUZtblJCVDVtSGJoRWlaTGV1REtMbVY3LVhPZE1GTjRWYklDaG5meHA0MlpPTzZYamJvbGNZWmg4bm9iTkh2dGVadDhETlk4UkJwcERjbEVZaGx6dVZua3d0ZnQxeXZFWXBEOXJ4UGYxMzBPRkxkR1RFOFpXdFNzeGZoOXRHS0tHRndYdktGT0k5S2dOSjQ4NVFMY1d6eDIteGR1R0RqTVFTRjVqZFJzYXVrc3pUZ3hHdDRfRldKcTB5c1ZET1k0MnlRSW9oY2xMNjNiZnhncGQ1WjhlaUxZSGhFUWEwdER0RVNncndKbmZhXy1rbEtuRUs4X2R5QUVQc0lXRlFieV9NdXBidkl4bjBicjlEeHNNUVVDZ0swc25VV3dzbmxvM0dsNVFadUx0Rm5EU09GcHc2dmFQLUViVFliaWk3ZHJYeWtYN0I3QkdPVVpsdUE2aFlRNi1VUFEtcE1XX0V2Z1hMd3pzMjlFTFJJeE5pTW80TDJ5aVdoSkY3S1hwcW50eFFiUVFtLW9ubElLUUlwNDF2Z3hxNG5RejNXTlk3bTk0Nm5BY2NxUHZHTnpSYmZrWHBCOExYTWlyUlBXNXNraXdYTHA3TjQ4LUNvUGRCeGluWWxVejIyUjd5WnpQUzZLYmg3eUJhTTdIMXEtVi1Wck5NWmhoSWtRajJydFBFSHdIcTJhMjd2bVBodFBIVzc1Z0V6U2JuWWFVMzRzajkxbVZBejZTaU1URWt1cVdUS25qOVZSWVdJYWVVbzRYby1VUElFS1dWTlJSMVBSNzNudlZZalpYVmdhMVhpREx6MHVGNmVvdWVUZXJvSXo4azZ6SkpFYkR5SFEtUUk1U0ZpOHFWbFVXRXFzeXl4dTM2cDhRRXdrSjV6QjhERndZbEVQUk14SFR1clM2YWNNZ29GWHYzRVpLR1BnN01rTEhNS0NObnZLV2pRb2Z0b1NYVlZTbmJWSGl5TWRGa1FDcEo2ajc0cHJ3aDRBa3R3U2FIN19jdHcyVmtFOHZYQWIzQmp3SmRtOGR0SnREUWNPVjJLYnRfOS1vajNkcU96ekFiMGVyTzJFVzI5MHJXc2xEVVhpZlRONUM5bXhqRVQxRXBIMEdacHA3Ym8yZzJVYmJ1dUxQLXNXXzlQVzVkMnBGYUJFd25jdXZtWUxEWGdybzJzWkFlUE8ycm1adnBlZTNWc2Nwa0N6TkRyUVdtVVEtenpvaldZMEMtYUZudWg3VENCdWtTSkVBMFNuQTlLbTBVM2xJRXVmY2tzdFh0MkdCbGV1RnBtYVVKQi15TDIwYjhCRzZ4dDNYbFFWNkJlTjNCUnBNdDlQWEk4S1dWaDJIQXY2WmVLNlFxOUtUNDJoMlBMSmtjNzVRdVJLdnRndWM3OWlLZTFCMDNHUVhGb3djMEJ5d21kOUpBT3B2RGpTenBuM0ZJbnpFRWJHQm5vX0xxMmkzelAxcGJBUmszTnU5a1AyRmYyeFYwaXBKdzVmOTVZQmhsVDNFelAtZzVmUDE3YzFYeVZEbEcwUUFSSXN1b1doTEljcWdwZk51SkZIRmlvWjdWNW1VR1gyZm91bFJDcFdCUVp4OHl4ZWpSUE0zMWZNUWwzQnk5Vlpzd1V4SExYTjRkUkY4Y0FpbXgtblhmQWc4ekRvVk9jM1RVR19FRktuNmpOYW1OVnBrQ3NRMnVvcWJBWklxWWo2RzhmY0hPNXBKSTVPY3pJeWotdTRuYmdjOHR5M0VGb1lhWk9CQ3gtYW5NbHVOUWJVNF9CTHBSSlFJUjBhTHdPRXcxNF9LRko5YU5WUEViNldIWGl0U29nSk5HM2MtSmV4UmJSal9NRHhkR0JNVWlCXzRMbENQZ1BUb2J6anNjdlRvWnRQX1p1dFdQUHJYcWdQNnNEd2lsVTR5Wno0eVhGSWowMzFIb3JRUnJia29RS2dacGtVa1ZrUlNSX1R3alJhTlBrdlNmN04tNGl4U3dxN1VmM0lnVWR4RVpSVGxfVWVoTGJUVndaa3BMWE1UUTFaNDJFSHJzcnJCaHdBZDNtOU55R1dudjBJTlliejI4YnA5a29VZjFpbEE4eHJqX0F3WFVKdWJWX1NYMVdPQUxfZmZmWldKd3NkeEg1QUstZkZuSl9wMmpUSlhrTzJqM2J1RllIaHdqWGw0czFYMG1obVpxSEhWVnpMczRpazhkSERfel9fNldGQi04ZlE4THNmbkhqWWl0WDFDWFg2ZGVQZk9Fb3pUZWlSeTdTWEdIbnZnRUEwbXVaSVhSNXg2RjFlY2wzTkJFZzJiaS15ejcxVjlLLUR6aTNaVlVtbVUzNXZHYXBqLVY5d0k5Mmx6b3hzc3BGRi0tZDNXZlJDMnhFcjBCcGFtb0dfWUdYb1h2MU1pNC1mZFNyczh3Q3VXZnRzdTQwZURXcFR4X0JVQVI2WVF2TnltakY5aUhOc0tFSVQtT1hlMnZ3c2dSQWhvdkZpZlpUQ0Q3X3JoQnFWRUtXZER5bjFVbnlfZ051VlBTNXNFTUZJNWQyNlZHZ2hzcnF4REZZOWlJZlM5RDUwOXVuNlRKenl2b0JHUVpzdVZTcG1MWU9DQzVyQjZnRHZYRmFRRmZZYXdGV3hGOGZzYk02cThwWG50b3l4MDlublNRM0pzMHlyWFo0bDJkelJWN0NZd29BbDZUSjlPWXduQWk0ZTZOMm9RdGN5c2pPM3Jid3dqb1E1M1RIakEzZXFvclk3RHEzTkkzUmRJeWRQUkNlVFhOVzlDckxpWm5uR0FSWDlwQ05DTm94TFdfcm9QNWdDbVY1TXdfM09IMFdhanFXNkZFVDZiVnRCeTFJTWhaYUloNV9tMkZDdzhiajNZVVFnaDM3SWFKZDFIWVlFTmtINHdkOVA3MEJyNUdFLU5lbmFGa0FERGhhZHB4Q0pPRmNpZDlKZGFST3NSQmRWTTJ4MVRhcDhXUmtZZENCZkxMYXAyVDFsNEhhWnl4WElEMUlTZVFQTVg4TjJvTHM2VGZvaDY2NE95c0RvaUphZzNwRVFWNXd6MG1FM1AwcUpjNlJtZHNKcVlBanNpekJKWmQwMk4ybVplZ1QxNTdpdXlCSU85QXNrdnoyRE82cHk4U3ZzZVRPdmNoOVJlN2FRYlFHdjVobUIwTFlsOHlSREJJRXRSbUozRzJLdmJrSlJ6UkZrVHZ6QjhUMTMzZjE1a0MxOFlRa2hYc0Jod0szX1hZRnJBN1l1ZEFCcHhjczlXdzRvU0ZnRGdLVDFTNG9RNnk5cUpuOExpcjdnZFVTUy0tR2tfckotVy1WSTV5aWRYcFFtVUFkMnNUc2RHVm1aMmJtYkdOa3hYNmp3bXg2SFU0dzlweUFmRXlxZ0FjUnFRandQUXVGbVNPSGxpRHZsWl9icks1NHF0YWswWjB5NTJUcGpfMjJHUnJrTDExdUZKX0J1TkdUSHVqU1B1TU1uNjl3WndDWDY3dzV5Y0pzWE1jbEZ6clNDV2k2WF8wN3BXT2ZtaWpGVTlGdzR5Ym5ZRlVmXzlSaDl1ekY3dnlmaGVWcFNKOXA2dVY3UnZZTERoM3ItUmVXVzA2V2tzUVRXcHotWjFjSmduR1pfM1QzUl84Y3Zlc0RWTWduMlJrcGxnRmdkWjBqdHg4TVJWeXpSTFBRS0FKOXV0MzB1dFJvV1lTb3hnR1NNVnJTLXpFcGd3MUIxYkQ4VXZVZXBuMmVWWlRLTy1xaEJKLVVHRjNqUG5FQ3ZJYXh6ajF4aVE2UHVkeVptMDE1Q1Q4QnpFNmNGYUQtQlhGSDN1dG1ibzBxcldVSmUtSlVhMHpIRFNfZzZmQ2lFa3BQLWhVWDZjdnNrRUYzRUU1MVNpbnN3M2lkNW5MTVRpZVRqN1Y5Q1o2ajBRbTRueU5HY0dEUHNkWTFMYlJqZVd5V3hqODlfV0Rnem9tbFpfdkZuQUgtNElnVlNrbVg3a2FqZEFJWXdTZXNJMkVjTFFucGZyeU9KZ0JFQVFJOTJ4c0s2eUZ0SWJ1aC11SHM5d2U4emE3UEVicUxZMkNVRWh6WDAyX19fOWNuSWlnNlNMQlp0eXVfYzNMa2RpTVZzczFfY3pPZ3I5blhSSGtwcEE1dzVUR3BZYnc3S19nWEdUWHVrSGYtYVpuQzZIbDh6cnpDTHRJVVdGNlJwUnRyd01DN19fd2RCYXZBNnRwcGUyQjJ5dnU4cE5kU291WUVJM3diSHdWNDNzWks0Y2RkRldLcFNCVW9BcDhmRjRQSUMyMklqNnB5TkhMX0R5Ymh0dms0eWlpNGI4bzhLYXVYMlJWYWFfc2lYeTdMSG9CbUR0VlliNzF1VTZFdHp3dFdmeGYyaDlUOG1RYUliRGJpaGJWMnY2TDJWYjBweWpvZTFTcTdOd2RUYmUxc2djVmV6UkVhbGQwUlJOZ09XX1I3S3BhUWg4cGx6cURBTUpVTDlDTkdQOHYtWHF5SWYtdUpOVEhXc1RQOWhIVnZKZkhoU1BVRlJuUTFrWVRKUHZFWWp2d1VBSUZWdWk1XzNrRmpnczlQYThtSFNROTNwV2FWVmMwdWNwdmUyYkk3RGtyQ2k5LThRUmVsb2dMeU5uaktkN291YUNlUms1elFxbnZKa3dlcGVNVmFVanp2bDRYREVjSWxUODY4S0RDTDhBZG1jS3N0c0IwdFByc0IyR3pULXlFYUdEbXFxZk9FM3o0VHR6Wkd4RWNnSm10TnhBLXAwem9zalJqeW1CSUNnTllEODM5OGNCUG94X3lpOFlpSVA4LS1hR3NrSDhmdV85U2IwTldjUFQ1b1JvQ3hxTTBKRGQxUGlzbldkZUdkLWR0NUczZ3FqbUg2TWY4VzI0U3ZIbGd4X2hCcEtPM0NXckcxaEVVamFrbEJGX0lqczNzVEhrWGk1RTJaT3EyZVRIUUZFY2tQN3FwRldTVHc4dkxEaDlMT1pSX0pqbGstZGpVNDE1X0Vka01LOEw5TUhWUk5XRXZPTFB2aGJNRXQtczRfSzBZQV9xZjFZYnhmSFJ6NlRjVFJGbG5hazFhQ3FDOTBaeUNPNVhhNlNrXzBJUzBKZDE4QmpRZ3d3c2QtZGVHckxGcFBXMm5SbUxUMW1tb05qV1hRek5JSEpnSU1QbXljUTFlajhycjhibHFBVUZ3UU9IWnJsNWJhZE1OU0dqSmRFNE1PNDhjTFh6ZDFidDVpQVFYNU8yRWJBZV9YekRZbzhvTkpNTmdVMXN3VktHaFlxWFNUSEE2a1JmNmdGTlBlQnVldk96bjhHbE5RelRwWXYzaHJrSXloZ1Z5TVMyOU5SSzJaWmwxdWUzeUZNVGZUYVFjbW5GbXhSVWdib1VhanlPNVl6ODNCRkxXa3FqX1BPRldJb2tLeC1XeFRrT3BNZjJCRTMtaUtxOGpVeC0tb3N3czZLTmpmT3RZaTdUU09zNUNSUEpOWHJzVkVLM0lIZGtVRVZWM2taTlVWMTRzd3NOdXVzUnFUZnlnbVRRUFlpcWtsbGpkcXZCaVlKa2JfZmNOeFg0aXJiZkI3VUd0LWMtTXQ1TE51UEstTjF0bzh6eERlV0FYVjd5Wm92eklDNnNDd3U5SFZsTE5RaEphamlqTkxBc1dFSWtoOGpKWWRqU09mZ0FUc2JOaXZBb1JITGdMLUhlTDNTODBQVlVLNXpDQmE4VjdGTE92YmV4djMwbEFEMG1jaGhfUXZfeHBUemk0Q3Y1VThLVDBsLWtDeXVUaEtzQ2JUYUZ0dHpkMzNJSG11T0tSYWpsYW5iY2NqLXlYV0pDZ1NBZmd3Ymd3VGJYdzlkRHZ0RmFxZklPd05aZUxSbEs0ZEdfdk1pdXNNWndUOUNhWDQ2SUgtTXZNTldxems2c1B4UUl6T3hfYVM0SW4tSTJXalBDam9JWU8zM1U3VkNuUVpQa3FoWkhzUGdJQU9FZmxIQTJ0Ukw1UGpCMXRsSWlIS01LdVFpQkVscVh1QnRtSGM5WE1jNUdjcnN3cDNhUEhrZWQyU2MtdTUxUW90ci1YcmR3ZDIwMnR0WERyS29QSGhYNEdHLWpMOFREcENsOFFDaXN4QmdCZTVlbXI5SG1CaXU1dkowV2V1UDR0MmRvYlB4cjFmeGFYbnRRNjVfLXpFYTl3VFZrRFBrakZJS3otd2czQV9QeVJ0TkUxUDZxREZPMW04QldpUXdfZEdBeFItWVVYTGZsTGtQOWx5X01HaU03VWRoSkRtQjl5Q2J6eXVWbkI2akRENE5uV3VhTXhRVWJqZTU0TjViY3BPUWppeGw5U1BlckNDSmJXUzgzQXlSWG9GQ3BQbGpKYkpiN0lqd0dlSmUyR0JYam9VZVR3clBXV0dMTzBudUI5aEk4eHRVMlZCVUktRGpIUDFPNm1TUHFIbnk1Z2Y4RHlzd0RnTllremw2aWppbm5KN0hhY2lwaVl4QkVKVWEtaE9SellVLTdqaENPSkpmemhqakhBRGRtMmQ1MFhhdVpmLWs1SXVsYVhuTU50RUlpR1NzUUpFUVZZamdMTF9qOTRYb3FjN2I2YUVJNGVCZDdQQnV0Mi0xNXRzQ0p1d2ZtQ1RSY3gxRjN5MVk4eG5HSEVwYnNWbmpaTkxnbjV5UWs2ckpmamg0UGFpYkRWNFRNVUJYbEVEWS12V0NZNUJpWDNDaENNb0ZGTVB4Ujg2OG15VlhGeGJqX19vNmdhR2ZwaDlkYjhYMUtNR01WZnNDNnloVEFXZnFYaWlpRmotUkltZkJjM1FxVjB0RS1ERUlwdEZvQkRpYWVNdGRNRWxldnBpSEVIVEZlcGZJamY2M1RPMVFVQk41ZVA1ampnaktrVlJialdGMHpmdE1Nb2JEYm5KSnFLVS1FVkYwaEh5dWdqaHJUQWg4RHFTVHJBNW9LSldQSW13aHoyNkVqcFV2TTdwVW56eEFQSVc3cnVtZEtsUnBPaGx1Zm1ReWZ6SC1YOFdWV0xCdDRWS1B5V0xOWktSamx1ZXl3LVdTd2tEZ18xX1FqRXJMQnJoano4Q1E3N21ZNTNIWVU3QngybXpLYlA2MzZiSThQSW9nQXJNYXEzc25LeDJlXzQ2bGtLUUVTSTJDajhXY0dITTRpODhUX0FrWnR6R0RxNndka2MtNmRQN3lNbVplbUFtcWxsYU9BNUY0SEtfU21yZlFXZDFKWkJZTUU3M1duZ0JCN3NEQjFvN2dqWG5pUjdiall5U0RlRmZqTi02SF9SX2ZRaExrMi1yNW1zVmpXR2dKUzUxbW1MS3NvQnQwdjRFTk5kZG10bGp5UlN2VjlNdHBVYXB0MWVJVmF2XzJPUUZNR0tfdDRJZmJjV1FKb25YMTh1TzhCVV94Q3UzUkkxbjd3ZFpDM2tvaGFHS3VPbldSVHI4UHZtQWhkdlpWQnhkeXBraEY2OXJIV3RBUUJQbjdSRE9IWkdubXJ6OFlvLXdmZlZ2bjQwN2hkNWZKdkVLdm5oSVhKSkVKUGFGTmJ5UDlmTEdFOFhQUWVyRUVaNlJZempoVDVScXNIa0hpM2ZCOEZOSHhmMU1ySkF5MFBFckdlM19JVnB6MGlOa19VTXV3SVFqM2Z0cmxtM1l3bE1Mb24yZVRZdUx6cEk2N0JDM1FPbzc5dm1reHQwQ1RUdWNraTM1S0VmRzFVNHB4bElFRUFNTWgwMm95X29qaE8tX1JnUTExbmMzWWYxZ01VVG9TN0M4TEFHMng1WVlEODBFNWVSVTdaOGhlSjgxLUpRZWxxVTZHSEVLU0didXkyU2hnRzZmWkg0WmF4T1dOUkMwXzlBYWlmamZkclFaVk1DYUNidU0wbjJoeUZtdTl0SjFKbzVDQ3NwQy1oYjhtT0w0ZG9QMWlJQ0hMalJEVDhVcTkxOHFhT1I0LVNMelZ1RTNiOGVyRk1EMzk0ZUJ3cVlOUnVUMW5RcDM2TjJ4c0JFdnZMX3phaElSelZROFR3RGozSlNFYkl3bjc2bWZ5VHFKUTBSZ2p3RlFxZklQLU13c3JOQ3NHSTVDVGk4alU0VzJITzk5MThUZDZQcGlQYTNxdlBIN0EwOFBOX19POU5WUXFndmt3OFFnVGtwT0JsRmRmUmVBOWZXV3E5eW1tNWhyQkdvUTE4MEEzb0VibWJDUE41MWhtTktmeUlzMTh5Z0V1ZTlGakFGT2MxVENTczh0bXhiU1YwVWlUc3lRRVdqYVJwUTBsbl9kRzUxSzNYTVVzdEtlZkxubUIyUkhzNk5YZkZPUzkzWnF4bVFsLV9iTmR2bnBjTUkzSlJENEVUZFpQMWYtenltV29zSUFXN19MbjJNVkR4bFZPWGk1eDdmRWJzV0hvSGFQbW9UMmowTmJMeF9zd2taMzMtYjhRd0pNd2Ywc3hUREV5LTN0SEpCU0RHbWx5VndHRlBpUWV6cWxreGhwOXRNTm9UV1MzUmZWYXc2SzRjSXVnSUNUYVM1cVV3cGtFcHRCZjg1VVd6d213dXVqdHlEV3dxLW1OZVFTMXBxdHNFSnBxR3V0YWJFcFlfclVvN2hHMG45X0tpZ3A1c19ZV014aVlVSV9JTUtZVnVSajd4VWlWUUp6N0trTEEzY045ci1BdEtyUU40UGdPcTRwLWFZdjdzMlhxRkRWa3NiSWRRTGE2R3BBb3phSDBEckFTQmV0cUtjZjBoUDNMeXUwaWZFc2U0bHcwd3d2QVhxSjk4T3pTejNpaTdBMlZINWg4TmRrWjBqN0tMMjNZMmhqeVhMcnYwdktvODFEZkM1a1p4N2t6SnFjMV9MOUR0RjdPWk5nVEZZTm5BM3M0bEdZNW9taHNOZTNwR0ljN3phc1FTVmxhbFRHQmJTQlhvdmkxdklQa1JIdWVkOF9hdE1RMmFmRUZxVjdyUEkzUklJTEFyVGp2VmxocnY1UWYxVjdYeGdaNnZjbXk0dkY1V25GZDlPR1dXeGNmYThJNk5OVWplWXM0c19hZ0tqOWlsVkdjcHhHSlFfQTJXMl9WendZVE42cEdzY1dMX0ZRamZyaTNFRWlHbjlYSWJndzRaT0lNSlJSOVdPSFp0eDQwLWNNb1ZGYzdFWXJINWZWTExFN0ZiYlZ5T1NCamczS0thdHo2Sl9TMkpsTjEwQ0RYRmpJNGd0UGtya1JCRmFtSE8wSEprZERPLTM2MzJHU3lWUnlqS202Yk12SGRnZnF6YmIwREdTdlZNOXNTZ3JUdXVueTF4RHVRRnhyT2JldzRhUFNQZ3NsNDV2MFp1OGQ4eTJuM3ZwWTVLVG9LSmRmRXpLQksyaHNiLVhQcHJoWGVwRThQd0tfV0U3c1prQTQxVG5Qb3JiSmZnRXV5X09sLVlZc05LWWlPV0VVWWNqS2VPWTJvVDFXNjlZb2I2cWVwMm53cnM5ZlpiLWhqeFlENk9JYXFGbFBCN1lTbzc4eEFtUVpPcnpNOGtpak5fWkFzSmZva0Zqa2s2c0UzQzFxeGxJa3V3U3JzMk9hVDJTVGdRbDZUcUFMcVpqNHRFZUVvdTlEZ1BmUG5aM09Wbk9JV3Q2UlQ1UTE0TFdab3M2amE0Y0d0SEJ1bURTSEFWVVZLelpMSnJfSEw2UjItaUxXa2tlTmFMZDM4SkVDd211emJfbktHYm1qUjZOZWg3WmZVdU9feFNPdGRXZGlzaThWbkszQ1Ixc0RfZjhSQW9NYXVCdkpFUUVFV3BvX0lLaGdZcEMtVThQbVJ6Q2VXbjI1VUtzTHhWOFUxQzNVakQwTlNIYTBFekpLOGtWRElhMXJNUnZmNTNxSDl4RkJTUjFiUE1ka2Q1V080XzVKRWhwYVk5Z3Jqa3JOclFGN2ZTQ0F6TGRhS040QjREZkY4SmxRaXhXS3B5dlZIbjgyVktUT0xUX2g1bkFyZnRNSnBfZnpiRGwxckpMbnJwNGJxMHVITW43VFBndlVEZVNqREJTSldZeUNtMWgwX1BWYWZyekFLTFVpRC15aS0yNzBJZnYzZWNNa3hfRG1vSlJkcVN4NTB4R3Y2ZHpCa0dkMG4wNWtYVzNtVmQzcW5WaDJkUnM1ZWNCOUFZY2g2ZWk3dW9NVUF4UUF3TC1SSVBJeUY2alBjTjJBQ2ZWRW54M2NJT0gtUmM3Q2dGd0hqZkNmVkw4SElhVHBReDJJMkk3bnp0Y1lFV000bDkyOFZmLW9UdGJDbkRrdEg5X2FweHUyS2xqSmdGeGdGSTJBNDR3YUF6b2lUejRvT2hSQ0NVcHNrOTMtak5XbTN5TXB5M1JfR3JVdUk4UlRXc2xBeEZ2V0FPbmFwTU1fWHZNdm5zMHJ5NW8zVjRwdTFRMEFMcTZrYVhqS09kbE4yeVIxTVkwTHdjRG8yYkt2Wi1UaVlpdV9oZTRlcTRJYzFQRGJ1d2xKdmNucTF4UmY5ZW5qVW1JRkNVZzFzRzBMdWNQeGpUNHIzaFpQX2U2RzFfbDhYLTh4eUs3RnBQWlc5NkVaTThqZzh3Ym9SNUhIRXRMR2lySkVWZFhwNG1RVFhOcnczRjZidkpNd3g4S2NyUDBJd0c5VHhqcmVBbE02emJwMEhFdll6SjR5eGJwclhrZkpLWnE5U0lCWHVkTG5QMU5LOUxycGlEckphM244NVg0eG9oY0ZaM1FnaWk2TkVZT2xudnctZFRIX2Iya0VqMHF6bE1SVFpodUc2b1NPV3F6NDJic3QzVFNvS096R3MxTmUzaTk4RnowOWtEYTdKZFNMbVg0cGR4Zmd3ZkVfa0NtXzE4M3VIcEhrdDNwWkdpOXc0M2RDY2xHRk5XLVQ5YnFXY0l1WVAtclZFbGR1RlJZTnZTTnpsT0dZV3hfTUNUeDdxTklsWGFBdzlSaFd5NmY0TDkwczRzYXRQaUF3SVZaZm5oWjBNSXR5dW1kOVRYZWJJTTdNNlVycEVLNmN2bkRSNUJuUV9VRUF6MGJHWTY3cGJDbDBDdVZDdDl6d19fUFpraGZkb19NT1JHV21rOGFiMURZQmc5U3VaNUJucTBqN1pBVk9OQXZ0aGZpSVd2S3RWSnRBaXNXTDdkREJyX3ZLdFk5WHVhV1VRczFpc0EwQnVLQXNiNTQ3UTdQekhOQnBqOFhwMHNVZE9lWmdDM2pJV3M3ODdGcVdrbmtmSHkyV3FLUDFQdTB4cVZvdDF6UWhhaXA2QkxRVzJzMnlXZmQ3c3lsVlFyTjlvekhXcjh5M1M4LVFjS1lReDZGWTdRV0duS2NvWnNSN29Bbk4teER0YV8zYXZYakh3X2JKTm5rU2hZRTFpQzIxbFhVY0lucS1RSjJQMXN0VkJISi1tWlo5ZDBPU1l0cHVvUExNNlN5MzlYRTNCakxRQ2ZEeW9HYzdEcTFWTjRKRE5FRGc1aXFnMlgyMWtVVzNuV2FIenpreEdPeFpjeEt2SzZJRGlickw2WFhWMlVweHAzRzBKNkhoMUdMQllodDExQzZDc0VwZ1VJbllBbmxjTVZ0ZTFuVTRiZ0RRcjBnUmdzZTUyamkyc3RLQVNaNDYzVUdJWWVGZ0ZqR3B3cW4tUmVid1l2R1h5MUQtdVNkVWR2QU5ubFhaTy1lQ2x5dXVubjBsUGdlaWdtOFhQN19SWkxmRFVaUUdldGMtYnNZakd1ZzlaWGFzTDQtVEQ2ckVQdThkUDE0RjJhdkJGZ3BPY3BkckN1ZTRZQ04xS09zYUQ5bjFpemJFZXlTci1xNUd1aXRtSGRLTXJ1aEFjVzdzeVZxZGpmVG1CemRVbDctYVlWSmdJcTROdVJxSjNUTFNrbXJnalA1S2toRkVpbksyUUJoMVJwSndSckdjR21TZjRZREgxSktvUU1weW0xbEFVTDdlcVRVaVpmMERsUG02TnpHYURQeVlNazYxRWd1NklkWkFJUEZFcE51dVpIR2ZMNEJGNjFaUzFSd1F5ZWpPdTV5cm1hV3hjN3Q2ZHFvTU4yR3lSN0ktS0tTQnVOZ09jTG42SDBiOVJKQTlORWZ2VlpwcGZwejJla2M5TW9pUkViMjdZWmR5ZjFtbWFYMGZ5T0dtdjliYXVNTklnWWQtSHVFYWM0ODVFazdycEpnbnQ1Ri04dWstWENkeUZwZkRXTFpuRFlnSy1LN2lnWVJqeUlwUk9vZjUxMlYzUVBUNC1UVnR0V2U3UlpqdlFKdy1LNS12bEszcWd6Y2ZrZWZRYzNZYVA1U3FkVkVFenV1ZzlZdEFRWjN6VDJNaFk2UTJUV3V0VmZBaU1NVTBzMTRmcnY5eXBuWjJwb2JyQ182aHBpNnFMYm9RLUFJSldnMDV2d3p4RjBhTXR4RWtJeWVuV1l5TWlKVUVrY0JoRXpVWFg2VGh1RkpzT2tnUUVidDJuemJnaS1NZlVPOTNOSjZId2w1LTROejdwYkJtR3BxS21hdF9QSHJzLVFTYzlscEpoTmFHSExvLWpyeXpZQjN5bHdNU2ZDSWl3N1p3bE1WdVVPNXpRcG9LdlNrblpFTndZRlJLXzR0WkRTYkhxVXNXcGlEVXN3c3dTZTdRWkswNlFDclJCalUzZXkyUXB2TVhTZVFwNVp2UldOTEp4Q1FqQ3hDdWtISWdlVE9jbkNzRUtORHJsbUwtdDFEUWFqX2hCUlY4Z2JFbTZJaUtMT184MmdjUlFfX1BlRTF1MnRWWlJ4TnZ1ZVZ5UzlMZTR5TVFYc3Z1a2xOdnU1bFNPd0UzXzY5UnhTSWZ4UmxFeW9rS2ViZzZZOHQxNWRYMUZlWlFiRHBzVDJucTYxdFI1d1E0bUpEb25ERVE5MmhFUmRlaGkxdG5Rbk02MTNXSGRsQ3pSaXkxVV91aWR6WEFXWEYwNGJ0LU1LalcwUVh2b1ItVE9qX2N5V2owMERSUVFZd1lQakoyQVViZnZ0dFZmMU9GYUZndGJhSmZFNk5uZmgtbm11WWZpQTRvdTU3eElHcG9QM2h1d1JHOXpDUVRiUnBOX2tHT0xvYm1MNU04WjNvdkFPaFRIbEp3WFMtZGs0cUVrTE9nckdaVmdHTWxCR3pucTJkTldkd0ZiV0JUVm5yOFYtMnhBcGE2b2dqX0d0cVRGYm94aTd3TG4zOWVDMHRldklLZE1mUW5GLXk1N0ZfZmFzbE93M2VxVTJJYy1PQm03bmdSSnJXWlBvOFowTEpxWi02UEFDUVpLSTNQSExCaDUyZ2tsR1Y0UVJTaVlNVHpkdkl0TG9oVUhtTk1fcWNMRXBMMEdBVDJWMzdMV29Tb3dDX2N4Mk1zdmpnX1gxTHB4R3MwM05jZnQxbndiU0FYdjEwWU1VNk9UTlVmNVdxU3NTUmdZTzFjWjBjVXFaNEY5ako2eDJTcmZaQmtxX2hqZEZiS0g4cDJFTjZOTFp2M1dTZmJWU3R2c2RYdVVIY05tSFB4YW9BZEw5ZElEMEtzRTYxZEdRbGRHYUhvaHBOZElDeUpIMXVoUjdiMUZ1ZGVveWNfX3c0MW4taXVhdFVkT0RQQzMzVGdiMFY5OHBQXzRsY05EUVBRQWdYQkk1U2hnYmprcmhYcmtMdkI1YjVrRmJ3Q1V4T21KQmhsWGh6OFBvSmFHNlZ5Z0t1ZWtsS2FhaGJfY1I1SVI4SnVQbVRZT3ZGQjY1bUZQVkx3NTh6eG5DbkYtVkdNRk1oSFFPUVg3UlpJNWFPZlpvR0hyY1F4b0FfSnY4ZDBjV3YzMjlqWUZNX3RzYlNwU0NYNFlHamhvZzlvMS1vcjRTbUFwWmJzMW9NcGdNWEoyOGhWcEJJVHc5MDU2dUJSWExSXzI3OW14THRWbFVYSE4tQ2Z0WlEtT0YxNHZWUVlzd3dfRjZoc3A2cVMyWkt6dkdSZkxhWE9WbG5qMlRuWWllOGRBY3BWX2s3X0xsb3RfYUVWYVlESVRlNVk5MHpLaVM5TnNZMEhQRURyZXEwQXdrMkQ1SF9qLW9rNFRHLWJtLUV2My1Sb3lGTzQ0Z1lSYVpIaHlfVS1VdE1vc29qbjg2a0k4UUQ0Rjd2QVdWanhuNUdrMnMzam12UzM4dm03ZmdjQl9BQllhYlFiVGpyZk5mR29VdmxXRVk5RXAwSWRlZDBDeGJ3T1ZaUDhQdlVpQ1FLeGN6Wi1OU3laWjB3Ukp5Z05sMUZzOWRfaVJRTEFCVEZtVGtGZzRsa1ZPNXFsMEkxLXkxY0hyQkcyb2RwNl90WE9oUTRPZzFiSkZVdTlSR1ByeGtfc0R2akx1LU05RUJRQnFvd2J2M3NGeG95cXhtbkJ0Qzdvc1FzR0lCU3JFZW85RDREckhoVGFrOEJZYnUxdmZzTzVWWUlFcGw1b2wxc1ViOTVIWHE1Zy1fX2ZScC1DbF9HaVd6aHUzUDQ3WFZkWEIyOW1TZEJQUDFBMHpYYjFfcm5CMFR4ZHl5bldvS25fOXpOc08wNHAyMHA0ZU5IUFJ4eDRFeEJVRDdkYmNPb3NsVWVvUFg0dndzWl9hN0ZSaUF6Rm5XbkpLV0FtV2k1aTJBUTRrc2IxYmFOWkdvcklpU3YtbG1XWUFJMzlmYzQwNl9BQnotSUdWWDF0TFB4VDIyRi1mdVBSbzJWY1VXXzhCRmZwRDNqTExocU1LMVBKWDlsWWctUVFlbjF4MDZKQXNobnVMQUFDN2ZraXBLTWxnVC1XTXlrSXNSa2N3YlY1WldvaUhiZjhJNnVkb3ZRVlEyc3JtN0ZwekUwWDdua0d6aWNsanhyLTlyRU0yV29KakV2V2ZEQ2pIVFVxY0Nwa1k0MlhaTHJxVkFqN04xN2N2aGRfZHlQN0dRLXBpeTVGRUJTYXJVQ3JPcFlLWWZBUjlHeFZ1b2tRUkwxcmIyNmFzc3FtWFpVb3JRZHQ0Q2wyNlJGRWVlNmNqNTN3V3FhQktjaXdpNUVoSlpxNTlqNlREWW4yYUVtZlFCNmItNmFTYUlwTjlnSGl4NHc3U0wzS3dtSHdiSjVVVDJpdnE0T3JTSkdVTG1PUWt5REgzWTlQOTVoblk3RG1rX0hnXzRYR3hPampfR1JUWGRXekxlTElLZFhBTDdNVzE3MTVSRXllSnNqYU1DUjlHMlJTRzNfNFBRd3VrTktZTHFIU1JwcTl3STQ0Y2lST0NmS3NHd2NpVUM3OXktOWxvd2lNdG90S2NFVVplUGU1VGdQQzdmeXgtdDZqc0pzajl6WVVqY3dNRjJ4UFIwS1lna002RWIxTjNYM0hBejhRYlRNelpWd040NDNTLURoQnd6dXhOLVNISllZZEJFSnFFU21BN0hJb3IzeU5fVFhKdGJCbEhiRkdMY01sSU90WnVCVFYyb0x6cUI4SV9ZSldTTVpDVkxPdDlrYzMwQVNTTWp5dE1jeFhIWFVNdHhKd29RQVUzUXRTc2dDZ3RCZkxuNkt4MjRYSjY1dDcwSDhwZ2tfZl9QTFJnczZYcmdONHA3MmZPTlZac3Zrc3dRUHV3QWphV29uZ2g5Q1h5amFoLXVKZk5scnA0MWR4dXdDbWJKLUFOcnNIbmtDbmlZbzd5OWJjQzAzUU5XXzBkNkdESm5RcHh2R212WGJJRXdINm0yNWRROU1BWjhOUTA4ckpiUFd0cnVUTTUwU3NnTE1rWDZGUk1hQno3bzlGbVQ2eXJtYjFvQWVSZ2tYR2hQa2pIVUd2b3l3YjNTTGVidDc3blVfbG03TjNkZ0d1MGxfV0ktWHVmbmpIZUY0MDlJXzVkSmNHdTIxcmZNQ21SWjJQdE1sSUNtc1BHd2k0X2R4MUxrMUNocXRhcVdiaGI2MXRFVnVjMnloUXNRS3U5a2l1d09MLUFRV0xkUU5Ta0I0bDJTOThLVENWOThlZ3p0OXF3LW05aExid0Y4b0FSYkFmQmpSRS1QaTg1Q3lON0w1WEZlLUhoMWhkVGNJNnV3bld2NlNDRHNTVnAtaHlkQTlHN29COXAzUUo2b290NDFPU3FRaHh0U1k5UmlyVEVBZVVKblhhYzh4X2JDQjFNRG5iS0tDbjF0RnpiOHJTb3RQVUNhY3AxVUdpYWlVZGhoVVFmUlZJTVZad0gyNlo0NXoyZDEwNnpYdE9tYTNpXzlJd1N4YllGS2JycGR6Ym1ZWjc5NnU4RkVWOEI2eHVIOTk2ZGZqaUNQQ1pwbTZDSlJ3MHdSaGZ1NnE2aVdKUVdHdWV4OEJPdXllWnR2VjVtd0htVFhDT3ZsSUFwaktvTWt2dHpMbWlmNHZsMUFFUVN1Uy1PemdEOFNlRkhyRXFzNjU2eGgtMG5DblZWX19fNmdLS19oWGp1aUlSRG8wamZKZFltckF6eHNGQ0lHRDdObGdWX3JCUnBGT1A5RU02c3JzOHZPYV9Ibk91SGp1VDEtUXNMaFlVeFVSLVh6eTBzRHVKdDFET2FxSUhhSEFBLW4wcHlKQnhLSG5SODJHRUZlejRNbFU1a0U5WWhqdkFpVldZN1hRblVGOWVFTVh5ZHVXR3U1Vy1yMkVaRUhOWlE1TzBKT3ZlajdEeWdIVk9xcnpsQW5FZ3FHMlBnTWdsNzZGT1NUX2dFUWNoY1ZzQW5ySUVpQlh0TElaYUZYaXpxbG5OeHhndDZMQkQzSHM5VlRieDRjSGF2NjZNVmZHd19pd3pveDQyRkF6ZkxCeW82QURrS2FJQkhHY1lGVU5Vb1UtbmxZbXctdG5vSmQ1ZFNSNkxUcE84ZGxPcnFRSFI2X1BNZk5zSUhGVElnS1JxaUxndU9yVndsSmQ4bVlpU3VzdmFudlgtdkp5XzF0S0FYdWdmV2VEUjU3c3hHQ21XcE1ZdWhxcUpKeG1hcV81cnZPRUlUaWdfbFJzZG5PSjNtdy1Wa0RrRkZVbGpSTFMwTzB1QlVLVDRFdThacWVWWmpXRjZrRzBPN2lUUlQtSHMweUt6Y0l3WW5RdjVITm1RbFFZZ2pXYXRRZWQyTDdBU0lMSVhNUUpFVUZsVl9SenYzeV9MazdWSkNOejVJeGw2S1dRQUxtSU9EVHh0TkdVbWZBbkhaWWNaRDlQcGFaMFFsbTQyZjJaRUFidVVMU0Y1T054WUZmSEkzZXpfOEVCQTBTT2puakFGa3VRNFl4cmhDVk8tVkFBSl85eVotenJXMUJKTEh2MDhwaHdvY2hVU0IyQXk4VXRpeVREdjQ1d0ZfOHJUNTY3U1FIR0FPMTd0b25qNXFJUXpYdklaZTlReFE0enFwVUREekwzOVhwNE4xNUxsOFRGLVhfQno2QmsyVXZQTWVHdk1IcFUxSjJFQ0pSeEVCODRYNGRKZVdhR1dmdzUwcUxIakF2N01FQThaNzVTc1BWSkJPZzBpU2hPdEZ6Q2c5R19Qc19JZWFvMDZxeWtGdUpQSkRzS19MRElmb0lfZDUtWWFQTlRfT0pxYm4wMjBELV9WUmk5bXpGb2lBSkhGbWJMM2plZ2tlT2NQRGItNlRqNVd6N3FaTWpuOG43OEpfZURwQ3NlakRYQnhTWXI3QUVpenFlekJBdUhJOFRseWVDcjlZT3d3cnF0NnIxTk1WRWlvY0p2VFN6LVBLbUthRW5vX2JSd2dNVTVHREliTEFmdHRtZlNzVmpWa1pKdWpQNlYtTTJNaFdFMGo1cVhzZDBYVUJPZ21sOTZtX09fQ05TRkw3UnNQN19LMUhCeG1DTlBERXp4RzN6eDlVSVBIMkFFZUxyWHVyN3BjZnpHU1Uwd2pqQUJQUVk1WXQxbjB4bm1SYWdWZUdzbmZjMXlUU2Jpc3pOUC1XLWJCNFc1aXFESS1pUjZpU1Etay02bjBwWi1xby1JMnczZVB0V1FJMllSZ25ZV2V5ek5oVzBLc3ZVRHlmMmtWT1RNak1mUGkwdW9NZVdwLUQ2TkJndDE2UWIxcU85RnFVSFVNRXdXaHNWeThzR3R6OHBOM1c3TjdSd1Fqa1dHb1ZhdW00OXJWU3UybW1rRzB6ZWcwZWExaEVELW80ejhmejBVM08yLUN1U1JFcldBeXJEOW1Ecl91UW5VQW9NTGVhNDFpeTc1QnZ1cnE4T2VvMmxuSG9sbW9LLUFhNFhobEFpUHMzaS1YUXBPV1hSWFN4cnNPa3lYdHpkVzZKUm5qMFBiaWdTX3ZCZjllaENTdWstdmZIdWFrVGk1clpOaXdvTk1SRkVtQWdRMEdQSEVkdGEyTTNLeW95cUpKZ3RsNEVOenhNV19Oc0M2SjVVRkFyQ1IycWNiclZnQTZlTGZuNWxrcUtEM3FUR0lxTE85cUJyUlJnQWJuMXlZdDFOVHh2cDdJQ1gtd3A2NWlhcktZX1FYVFVKZ1pLN0tGWDBiVklBd2pCS04tRm9XQmNoNmFMbnpnaVBhbjJVSHpwTVJTcUZKLWpkNGJRU29hV0NnY1RXYlhYSDRqLXhiSWJSS0pabHZrcVJENVF4Z1VZcE9vNXJFcHJSSHhYMmxlYlF2WWllWnBlV0NoUU1BdVJvbEFEaFNlTWxWNUVXOUt0bVl0dkI0LVVqS01XTmgzcUxaVkphMTl5aVZzSER6TmdkMy13c2MyZzVuWXJIZkVuaTBKR3RKXzhhd1p3ZnRlZUtydjBxUl9rTzdVU01wVVF6MVh5WXdTQ2FxUjlXWGU0bDBpeEg3MHBtTjFFbFQ3VkxzeGlDYUpwdTdWZHhkOUt1VllYVktaeHRZLTRYNElNclJLOHNraVBENEJGM2FlVWdxdGRiVV80ZTR2d3E0N1haSC1uZ21xQ0RpbHRJeUM0UDVlLUNPbEVULWZIUDExbHFpLVk0azl3VDhoeHVNNUJWRU5NcVFfNmxvT1ZUWUswb24xaEVSUWNZSHNleWUwRzRxVXJXa1pQSlBnb0h2aGEwYVczcUpybWN5ZTBzaEtWYnYwdF9PVWJfemUyYWRTNWpWX1Bka2E1MkU0Zi1TTV9MaWQtTEh0MXpVbjBMNC1XNW1LalczZzRDTHhZOHRlRHJaZkc0bU5YX25pQ3hCTGdsaERrOXdVM3Q2MGhJdDlaYkcxVEZnaEhUMDhUR1o3dFZNd0FiS3VZcGFaSC1SX0ZhdC1hWDhuUVdOVjM4NjE0b1B5VXZUZW9UZ0FZMG02dHFRaEl4cFNPalEta29nQjNaOUxNTFFOVTR1NVpXZEIyZDBUMHZjSTRTUnJCTXZvb1Nkd3RlMWlyc3g3NTN3QUI5ZGhCdG42VXY5N0t2SS1EbFdwZkJ2cF80ekNla2ZrTHlwOTQ0VmJhSGFqd0p3SUZXSG9SZW0zTGFaS0pablFoSzF1TlYwbm9uUi1jTEhVa0FMMzZESm1aSWZ2UTdXVUhQR0hhTXpRTnJPSjVMeE1sd2oyRkNHbXQ5WlNPcEJvUk5SMTREczJoYjRLb0NxRGQwMHVnSHZ0eXhTX3o5bzMtOGVEQnFqUnVQUHJNRlpObUF6b2FqcDVHalJEM0RBemhFSmpZZmN3RXFrZS1vdkdBN0U0VWhPMVVzNXVZWHZVaVV5a1VnQThoaVRPRlFXTVpkUTY4eElwREVUTzZyMm5Ma0wzREdTT201el8zS3dtWVN1a3ZmNnJsRmpuSVR4QTVySFYwNFBBNkRaRjBKTURUb2pXODU4al9zc25lZjdtLV92NFJWYlpDblJLQUd5RHQ2LUdBWmdXTjBRREVpMTZYbVhwck01aWRUWWRvMVRHaWFMNmh2ZDVrVkM3a3k4U1poYkU4SElvSkVhaGZGS3V4VlBxSk5oSnY0cXF3QnR2dmx5TGZTMkFqTnRURVFCU1NOM1BqYTNjZzBhdzdUaDBpaEowM25ieXdEZC1DdGp6OTYxOFVYeHdqWmNlNVBLeklWRV8yYW1XOW1Rc05xdWRDVkRMRzkxWGtCUXZ1UVM3VThuUW1DX1FkTEpKbUlCNVJVaG1hNnJjS0ZsMm5RMHJiZDU1MTgwVHdfcHRyWXhkQi1Rdmc0bnNEVDRUUEg3aUU5Nm9Va2xXZTg2V0VVYWVaalAwRXJIa2U2aDVlZVpIOExEQVZjVEpRdjhrbmd1XzV0MTFlTzJFNkpGY2h1MjJrWXE5eFk0czJSXzZHb1FRMDRzdXd5NXRiS25MNTRwUEVZOHRmMmJKZkUtWUtlMnNmblIwdGpNT0VOLXVBYm1FR1c0aGUxWEp5b0JHZnRiOGNfVVJLelpOWDQyTGllZi1UcWN2Vk8yY2Q1VVVFYVpfVHVDODBBTVp3N0NGNEZ6bUhnMlZ1UWZUNjlXN2RHb1FJb2NLaUVMYk1iVGplWEtzaE1LYUpKVFZJRGRjdmlfbXdmVW1zaWNSbWxTUm1Pc082UjdydncyeTBCUzZjZXdEMllLM1d5YnBmN1VQN19RV1VYYWF3eXhDbl9RMkJIcFJPeEhCUjFZdE5WQVg4bE51OS0wY0xvRS1xdlkxaU9uck8ybkdtUW1qNGhQSU5qUG5tbmZSUGt4QUtIWEQzUVJvRjJQb0kzaGF6M3c4b1ZaaWkzZ2hYWnRZb3Z4OFEwYmtwWng0VFVZX0JDbzhwRzU2dnlmbXh1NEdwRWxURkZUclRvbFFRakQ4Z3RHTGlNXzNGTWpRcjMtZC1idDJmb2tyVVU1VHJVQk16c01hMVZiOWQzSlRRdjFqejdteFQwTW14dzRoTXRHR1c5dGNvZld4MC1JTF9ad0lMV1lEVEtHdHhjTkUzRG9rLWxHQzA4aEYwV21BOVhkcUtSVmctUHhVNHJGX2pVRjJXVXFrU2p2bjdINkE1cTR4MmRKX1NzXzEzdjRoUVBHdnI0STVoZzk3dE1ONDZ5ckM0UGZBWE9kLWdib3RGb1pKWElCQ0NlUHJ2QndhWDFhZHZzUWFNby1TQnpORnRscGhHeVk2a1VYVEREQVloNTNvS0dkYVdMbWZvUVlFV3B2WWpZQ1pxQktGY3E3dmlseWZXMjgwS0JQSmRrNjF1Zm8zWTVyaEZkeGw3SWhjZ05rdElJT3VEcC1tcm1XOXdEcWo4VTN4RmE1cG0zYXdwd0xBM2MxZ2F6NElReC1ZWGlvQWtQU3RHTEpkdktxVHBGM1pxOE5FMUdHeU9Ha3J6STJNZ3FZRDFzaVJlUlVZUDFYUE1SZHpfb2Q2VzRTN0phTmU5dktyUmptQlFpVDQ1X1doR2dDLWIwbVFfeW83bFNMR0dIMlljSTNNaFQtRkZ1ZUNXTEdhQ184UnE1YmVDUWkxVTFabzBGcFNvRFpHZFVDSVFpNEhPUDNGczYteXB3S0Ezc1BpSi1nODVwVi1fcnRadE1oUzhTcl9fbEtwMFJaSEkwSjJvNXdmTXlIOGNZS2pFTmtKVkM2WkZRZUxGTENDQkZ2MXQ4V3M0UmxWSzdEX2ZfQm5rcE9jcHdnUEY1SmZYYmpwQ05VUlZiNkFyUTNZY1l5WWYxQlNHV3JvN0JmeXFSZGVldjhnZEtXOXFQZDlJQWVWWXh0V0pSblA1Y2oxYnNINXBFZEVpM1NhdzhDa1JDQmpQaWtoclpRZDd0UTduRC1VY3FLOE1TQkNKUllyWlRtcFlrbUpuV2xlZWxtaVp5M0dZNmkyMUVfekc1NjRkNnNoZHZWSlZNTEZuSDFSTjRCY0pGTkJ6RUR2RWdvRFpfdlp3OS1rVTM3YzhReElpV0tJb1lxXzRPTnZTaUNWOVI1TGdpMkhYYVYyREUwSlFWMU9zYzVuY1Z2T1c5NU9qMDF3TXUzQ2txcWtDWmNJY1ktUnJsTzlvRkhyQjJYc2ZhYURzeXFFazV3OEpXYkRmclY3N29TY2JzeklkaHFZSW1vbTh0MVZBTzZjUEJsOVB4aEFSaXh1OURWM3NsNkdKMkZRakhDRE12YUU1ZGlSYW5fdkZHTk0wMThySDgtaDFHTnBVM2FuNlp3azlpN0lvbHBKWUNOZjB2RlhCUUVGaXE2MVpIN0VkdnE3Y1BQQmdiLUFnVVpZSzZSM1NjX19HcDktanlkdlZHTFRXU29lQzFPckRNbllBRmd4b0FBLWtaLWViWm5FM3oyOVRrNXdhQkliRzVkTC1yeFRkN0FRdmJkT2NKSUZoY1hxbENXNUZ0UHNkRndvdUtvX0Rsdi16bXVpWk5YUDF6LXlLblRuZ1lRRGRnbWRZSDluZktJR25Ya29CcE51NS00SjBuanBaUmoyUndJRGdvaXpldkpLbDgwcnRFWmcxanhFNEVMVVFvMUY4UVBxOUkzQkFfVXFJdlJVU3FxX0VMZG40LXhRSWZBVGYzaTZZVnRJY0ZmdlFKcWdyc1JKay1PbldTS1l6bjB1bHhmYkUyaGViV1N2Q1pfanktRGcyOHo3TXcyZUk0cWRwYThZWnFYdEdFWXBNQi00ZmppS0lkZ05QbFpRS0JVSkdodm9FbjNpektlV2RFNjBXNnk3ZFMxUkl5NWpEVEVwX1J2R0FlWFpEQVRYLWt4TWxKbkxNaUZ2VW5MWldWREpSSEk0d2g3b09CaTB2RzhqU2VQamJQbnlnU25qbTRvUF8ySkZGdnJrMm5nUXYxZ1l3cjBoa1hWWEZkUzU0V2NRbXZfNGtwa2JuR2VaZ3cyR0lTOFVFZVlvdWRLczY3UlJVR3VWcEZxX082N05wMnQxdkltYm1WOTRaQlo5anJsRXFOWllRdDRodHRVNXdqUFJsMUEwTjNtcEFiQ0tlU1NXWTNWeXhvWjRjMFREZm55UE5UeExMNzhIVHUtcTJUOFloV1p6WXVib09yMTNUTkFjTm1ETGV4aldEUjNiTGdhRnI1VDllaGFvOE40ZEhpT0Q5dGtmZTBiWkd4cnNnUWVLVm0wNnF4cmdlZUhhVV9JaGV0OGEyUDgzWjJvUlRud2VBR3RoTGxneUk5bG9aSkpkUUczeF9laGV0N3FtcHRGUDNZSElBSUcyUXJOTGROYUd5amZPZnJVdTNjZ1owU2JGMGdTYzluOEhzRHMyMjF5YXBPTkFOejk0cXRBV1R2b19hZDFSY0NWZ1ZtMkxaRjdFcGw5V195bmZJV2dPWV9KOFJzblBYWWpsRENzbi1tNUlZeVVIY1o3TW15a1NlSzlKcF83T051bmJZaEpKOXJkTUdfdkdJbk1wajAwZEdnVmZMellwVDIzQUU4eUhNTEJTOHRlV2FhaE5PTThnYW9hMVRVRGZGV0EyZjNkb0kxN2x3dUFUa21HTTRuTERHeUFscmttVDNXa0JOc0tabVpQckdiNnhKVGd4OWJXOHJSVHFaS0ZRemotei1yTDI4OUMtNW5KajBBcGhtaTR4QXhRXzQxN2U2b0pQeFoxTXlfNVF1cTkyZ2hlbFg2MXZzdDBiYlN6dUJsc2FlbUNpQmFIcnpiR2p1dU5EaXpsVGxBU1Qwc1NpdVN4dG5zMWVsbjNuTXpZakhUVFNENVpIQnU5SkhfdEZuVDNpRjJ6RnZJVGE0MEZkX1JYY0FSX3hwbHpGZjh2aXFfOFIxOVVtSjB6Q2VMNUNWdDE0c0xrV2NWWVRuczFMeDNQQjI1cXItQ2Zab1Z6c0V1YWZzdEdnNFdWNUFLcUE0eVo2VmVfTWhOMGtMVTBFZkc2U3M1eW5VbUZVU0RQTmxiZDZ6UVVDZUhZcDR2OUVYSjk3c2pMQ1dDanBpbkxGb3IwNDRIaU5jUlhQQUUyUURKMXNWLXMtTmZhNHN5WGlvaGRGQkZ1MmRLemJMSmY4elR5QkxKTXQ0Z015QVB0ak42MktPemQ0TEVrcGY1Nm0yTTczMFI5cy0wbnJBOWE0ZUc0RTV1N0Q0RnJpbFlVaTFoeGxWVjZoWXd5bWQxS2pBRjY0UDQ0cFJQaEthTHBhMEd4cTBTOWNobDRKSHJFTHprekFFNTdWbV9hMTRudmI4dk1LY1NRS20tU3lBS2NEeFNfNmdTN1pZMTFUeG1OYk5ydjVGVWNyWE84SW13bmVuYk44UlBncldFSFA3UF9FUVFRZk4wbUdyWUYydjlhZmRHRzF5TEJPVlNsZHRWNWliU0toSy1RS2U4MGhQNkhZeTdrdFpzV2FfR2ZvSm1lY3FCSUItVE5acVFsM0ZWM3VtLWNOQ0F0RXlsVjB1ci1MTS1RQ3Y5aGZCbzA5bmk4UFd6SkJXdnVDR3VPTDY0YTBKcE1jamVKbm15OHYwTFYyb2lrM0hqM2MxRmM5RDZlczJIWTlTckhaSGs1RlhZcGpZaTBXeG5SaGZ1LU9TQ1M4T1AtYWlnOFZSYWlVdUcwNlJfVkZQQW1tMGNaOWFCaEY2NFBTVldMRmI0ZFJ1aURhTVZpWGZPblBrekR5Z0hEMjI1dTMyMlc4cHU4WTlfNVlkTmNXcWNycE43bWlFdTBuODJqRGJoQTUtQVRrWUVhVnFYWHp4TjVTS3hPY2E3amFpTm80RVlGcGRHYWZsc0Y3alpyUUc3bHZOZHVFTkhZYUtPOE11S0FwQm0tOXlZNXhnVFMxbm5hSDZaNlQzMzVnWDJWZTBaMkRxLXRyaTBsbXBNUFk4ZkVzQnhrZHJ3MkgtRE9VTW1LMG1zbktWVkRsMlFBSkhSOXlmQ3ZaLTVuTDVGU2x5WVR1LTZYTUlxbEJ0Sm52NmN1VlBLZ3doTVQ2X01WUzFBZUJ4NWd5WDFWdWt3WWhIWEg5c3hzb3NTR3pxWDZOT2o3UmpmdFpEYUZrM3laWTNHUlpUTk16Y3p4TGUtTmc3Uko0SzdFSWE2dFlONWxkSlBQcHJBTWIyNGluTFllZ2szZnBQOXN4ZXFHS2YwcEpsaXJxWWxEdFl1NkttV0JpaEdUNGtKMFdVX0lFZ3E1X0RsTTVnZUx5ZXdoX2N0V1lCQnBFeHRNVkF3ZjI3MFhJYkgyOUxfRFBvUUFsTE5zSlBjeG5VbnVqaERYUlhzMktjWW52TGNlaFdaT1MtUndpWlViMy1yVHVNQlBwamZrYmdRYVpmeGRNSVdhekxiZUl4MDE3TEZrLWJkYkh4RHBJWXN0aVJJTmZyZ2RZSzFlM1diWEJsTnh3bDVvNkYzM1FITUN5ZkhDME4xRGdiSk44Qnd1cklhOG0tT05IYWxOSzJJTlJxQTRkR1JTNktpOTIzRm1ucDN4cmRjM2RXTXNmNmNYRDYwazg3dGEzOWQtbjNRcmxZUU52TW5ka2Rmc1o1c3hPY3RWcl9OLXlGYnZZeWVPRVFJcjdMOE9wdjBZa3NSYXA3d0tob284YjBVV0RtMWFaUlIzM2NxUlE4ZW5uMVpWRzY4VzZrem52dkN2RnhyQ09jaGttdXNOMXBLTXRrdFI1QzFIZ0U5Wm1EaWwwY19zaDRBOGx5VmQ1clJYVllLZEc2Y2djbHltYkljQzZHTGlpN1JVSTZFNk1IUVhZV25GMi02ZEVVQy1hd0pvZENWbTNvYW52OFB0RDU4cnNmMnFVNW5Xa2RIQnNnaW1aQzNtUGpGTG0ySVljemp0SUNObTNxcTZWR0x2Ymx5TVlUWEpIRXFPWnJlMEVLWXdnZldQSjhsa1AyaGk1S1hFdEdnMFMzc0hxNHo0bUhORUJSMktjaDNfTGs4aGpBdUhBN2hJZ3YzUE5GY3JSSG5jOURZN1kwaGhfcWRiTUdLd3FCR09oMVFvSUtQWDhrSFdXY0ozRlVLZS01Y3JvRktsbUlQT3lVWU1WWGFFQ3h2X0tlOW5zQkxzWDJkQTFoM3lHU1lpY09vdjBPZTlfQ2QzMlEzbkNKU0JfUVVtaXRuWXJMYkNxakRTWGIwU3RiRjYtblN5Vm91SnlpR0hLRDhxdWFDbU0wSXNjdFVCdHZuNmkzSmpadjUzdWZzS1JqNGZDOGlqQ0EwZXN5VW5UaktMNFdmYllqbHRTU003MjVqTWZxRXpwTjM2VmxOdThvSjltTmRYdkxZT3pybUNYM2REVXpwUFktdnFBU0ppX2J3TGdJNFdweDJ1NUU5MkVaUEFCOVJVbkRLVzMwejA5SVhHRXZIaDB3dFF0UEFlU2dqa3g5d2hBMXp1OFZ6VUNqbWZyTnJUUGQxWlcxOWZUNmRWbjJPOUNNcER6bmJyTVFNSUZ1ZnJvVDgwU08tcUJ2d1hlZ2FvbmNNNVNXTDU3cmlmVmlaY2VEMlRPbHVRMGp3Ull6dkUyUERVNHo0X2M4VmF1emk3dC1KMVZsX1JhV0FqQzdCcHFkbE5mbUVKaDQ5VUtWV0s1RktxakNYdGlEODFFeE1nVnAzQWl2Qi1WeVM2TVpucFdERGh6VGRVTU5heHFHTnh2cF9RN3NNbmdIaEY0MFdTN2FuOXdCT1E1S1NtNHByS09NMmRsS3psNms4R3lBdXRRRmJpdnNfWXZOZ0VheXVxSGxZeUh4UnZZSG9fczl5eTdWOFpvZ1FaNC1ySjk2Y0xhUkd2a1FTeTZrWkNvTW1EWElIajFLS2FpNTRPQ1k4dFZKeVYxWmlyVWRWeHpwQ0ltWG12Y29kcDhYQjgzMFFBSVJnRGpGZjhUVkxBUnh6MVdtczJnVjh2dXE5bmlfa09RYm9zWmNUSEZtSF9UMzFEQ09xSl9xYWJvVTg4Q1ZTRk9SWkZ4UmRlWjFTUzBfYVVEY1FHNXFTNVloc2FxV2dyb1JWQlNUNVVBM1Q4WGlSb0QzODN6WlhrZXpDdXlHbDZ5NVpMc3FPS3MybzFSMnQwd2JDSW5pNGFEZVlpWDczdWpfOGJOb1NDNjl1TFhtYVVKWnJMVE9xMUd5VEJRaWl2RmJYTlM3d1hMeWQ1QUZ1YTl4OEpwLW5CQ1hva2hpVjB4OHFDRWY0TVcwank4emEwSDlKOHllTWtoQ0JPR3U3MnVqNksxVmJWTHk4Q2hOaTJTYXRabGtESlY3QVdhbzBEYV94Y1JXNVZGaU1IVlJ2ekhOYW1sQUJkY3o4ZDRfMHI2OG5nbkI4N1VMLVFCX3Nmdmt5UFdqWkV6ZVVlY21KY1B3SXotYkhCVVFBcUM1NEZ2cnBYMFlRT2gyV2ZoS2JraGlSTVlIVm12Q2QyYkRuMGRYMGM2bmhKN0FIQUNRSXhvRHY2bXVMazYxUzRDSHN5YWFPbzdPalNfQWotTmctZ3gzazViQlI5a2oxQkQ4OFNneUVsRHZWXzlyalFSbENNd3h5eHZuWXRNbGszc0xLR2lmYVVxOTlSa3FHTjM0dEx4b3NrdTdUakp2cDZldThQZWlWUXY4LVh2QmVwc3E0a2ctOWVFVlIyeHRqa1QtVDZULU4zbzZrNk9YNF9OVllWajJIck1zeVFUelE4RVVmM3RzTXppYmdRVmx0ZE5oLWNMdFNxM1lsOFB4QURXNlQ5WFdxRjRlbXJXdERBZjNRNjdqS1J2S1g1cEs2cFJickxiaUpFRHZEMGpDc2xvblhfWGdtdXI1aHFKODExTkZNQ08xWWk2ZF9jX1d6QkVHcFdBazFfVGlubDNDQm1nVFhvWEZzdnRwSG1tMWZDSEhDb2h6YWlLbDJuZDQzbFI3amdQTjJjbWdBVmxMaV9Vd2MtOXUxSDVCaU9neGtKeWpVdUotbHljdFRfZUg3cVI0N0k3MzVoSWJlUktwc21FVEJYTUpkY0xPVVFPN3drQ1F6T2ZiZzlhb0E0aGJhSnM5SHNmOHlOd2FCT0ljZGRCTW90MVY2N1hEV0RQc015XzF6S1czQkNDMWZfbm1KYlJLbzN5cnhLU1dFdFpxTVVJOVNPVHE2NTNVVXhIcnFGcFNUd3I0M01hc1FZaFdTWkFFc3l4Y29oNUtXbzZPWmhySzVzZVdRWXBwSEsyamcwRXA3c3BKTC04MEdhbElYRUJFd1NOZzEybTB4R0RfdGNBRF9COHpzRjA0RS1IcFc2cjFYMTUtY19JRE1pbW45QjVaTzE4NG12NWNQR1k5ZElrekFIdlp1TDVKYTBKTUxZcWF4SXd0YmhpV1lneVVIcV9jTXY2Y0h5S2Q3SU5ETkhscExFWFVBOXZvak55eHlaRjMyQ0ZVSEdEYkprOENwNG55MF9sNWItdHZYZjBhYklzdlBhSEh4YmNRSTJqU055emJ5ODl6M3I5a0pjYm5KWmZOaU8xVGlCaFpvdVJRQ0JpbXBDcVZYNmljUzg3UGJwVDZwc2xhTnltdjFEUzZ3ME9sWjZCb1NFNDlzRHdrSVFxWDlpcDFSY0VHd21uNS0weXN6dnBDYm9XVXBOX05RWTFxSE5yMFFiZWtNTnhQdWxjaGFjbm11bkJleDMtLXlUREo5MzE0NFFZUVM4YmxTaXhnMWd3V3NsSi1zSmRtNWRObkFmMG5YM1NieE5GTmxQTThTTzQ3WWJQbExZSXo2X2phU0IzeUZGOEdhM2U4S2xGVFA0MjFCbXhWT09zd0xOb3ZqampCZ1R5dDdVVk53cTJsdW1QNTN4TTI5Q2o4U3hXV3NzMDlWbGpoNWpIZ3NTR2VRQ2lMTjlXMUlmUVNOUzlvWjFSYTc0VUtmV2s0a2VFdll1M1RucExkaXdXc3Z6ODUwNnR6VllVS1BUS0x5OTl5ZE5UVjNyeEpWYWVpVGFTMC1SN245YlFrRlh6YmFQc1Z3Ukp0Qjk2Y1ozblpGcUNTR2gwQ3dBMjBPUEFZNVVydVJIa3J3dndmV0lQTnFBT0czbTVqODJRQ2J1dWlHU3ZOX1cyelpWaklkNEVockpTS3NDWHNMTmdYSUxJcXJQUzdSVWhwd1dSV040d3BGNlh6VExhTUxUNEFQazhXQ2FmdVhGQ09PVEVvUk9pOGdTeHFLM3FnTjREUUlnMUZ6aWd5eVdOTHhOaFZvOTc0VFU4c0xKSTZ5MFE3UHE2LS0ydHpYNFZkQURYM0RlRFFUMmVDeWdtUnA5NE4wb2lmVmNuZFdNSjhnN3o0Y3RPc2xZRXBkcjItRnlXcjJzVERoVmhqSTdMaEdpOGVGRHBMbnZjMGtYVW1zMG1oTmp6WTFPdDROeXlJQkZFaFgycG5JU0c2MVppV1NTd0tkUW5JTERtU19JSm0tVDd4QWRDRFl2eTFPLXloRXVkejhNM1RoQURsa0Y3ekZlNFZaR2o0RFEwRGhDbzBsckJvcGVSbTl1STJGaFVLLTBRUVdWZ3BWUFVtRzFfcmRxTXdDcFN0NnNlOWR6VnJfazdHSnN2dkhNUHdqVHo3NlJQc0VJOGpqUlc2THB1TExsVHBCeWQyWEo5WTVNaVo3a255azlrcXNUNUR2aWZuQk9XLTV4NkRhdDZtYmlfZU5yMFJXcUVlN1JYRVNVWHA5WVJQUlh5WnZ2clBYRlJDdUFKU3J0eWJCWE9PZ0V4SVNzU0xDbEJGQW8yTjduRnBVOC1Nak12U2pkeUhWZGRjMzJzNU4wanJualctSXMwWHh6V3Z0OEV3VE1ZMjZiYTdiNFZyaXBHVWwtT3B4WURiZGd2Y2tqRjNlMk9ObHNOZFRQTFQzRk9CR2Q0UndjSDg4NHU4Ny10Ql81TmZ0eEYwekFHQUVwYnBCTUNLSzR6ZG9ITEo3V1R2TE9rUXc3MDZ6V0JNV3ZiWkJuV0xYSmdsaVVCZk9EaWZUUFJxQTZzdnhzWHpGNk1BSnd6eFFEbVZObU14d09nbWhJOHMwdFhrb1J0VkJTcy1IUXpFenRJcnRURlllYWc2SmNHMWxGMk1rakRTYjlBaktxU0c2TkV1cndJMzNCVGNLUkd3cmtIa05vUlQ5VV9IQ2NBbE9sRF91Z1hpWmlQYkp3Nk1md1gxNEFlV0c1QkxMdkdpeTZmdkN6anlrLUNjYWtxaFhHbXZTblV0b1VoZlpJV0JhODNXRnIzX2ktbE9VaVQ4M2M1ZGJaTW5TNXRsZ0k3eWhidHcxZWtyZzdlcklXSGZ1NVFQN196MDJjYlFURWZTVDJ3Skh1OXJlMnQwTlAzYzhyNTllblNyX2FoTlo4a2Iya0tSRnBQM1FVaktXY0NzWW9uMEwwQXU0SjUybEdyU2IzN1B6LW9vMGpsY3REbHpXdElkay1pdUJVNjlKVDZpMVJtVXNVbWtXdkZQcV9SRnlnazVpT3N2VFNZVFpndVlvcU5McTlMS3FNajgzVGVvblI0LVVtMFRVanB6ckJJZXpWQl9Ra1FncnlRd3JoQXl0UG9sRmdKWndaUW1ReWlSVWZtcURjdEx6U292QnRmNnpvcGlPcVdYa3JuWXpWMEJfS1FZTW10RElldDlpY0twZlQxTktfRU9EM1RMNjFMYXVWd1p6dmNmd1ZNbzg5TG05QmtQSFQ5RUJkLUFfQW9fcE9yOG9iRm1JSGNmeUtaQVdZVlhUbFNyM3daTkstOEZ0enFOaWNtc0Z1dDdBQnRQaXRneU4wYWhNSFBOVXBiZlpVaDZoYTROZGdJOU9wUmdLUU11Q2w1RTIxT01sWmxodnFqYnR3cXA0bzN5MGcyNVRGRlhHM2FKdEpuTUVJVzNzdVY0SHFOT1BKWlZRcUZya3lNQXVGcEEtUTMtc0JwdFNfZDJYWDBmZ2I3emxiMndjSTktMkNaUUhRUnJIMzd5a0xPbFRWWVlvYTlKdS1HYml5SVRPSTc3QkF5RE5HSTBzZDhvcG8zRDhLaVk1S3l5UTFqSVN6Zm5nOXhBVGdiaUtRWWlvd0FtS090VEJubWpINURRaTRHWnZnVFVVand1NWRjT3JOaDY1OG5YRmc2UlZGbTlHb0Noa0dCVUNLOFRhS2RTdGNseW5jSVFNTEtGbHlhZlZCeDlQMG1nMTZfZHE0UEVXNmNmemVZbzQ3aGxNY3NTQ1p6d1pZTUdmbi1wLTktOU9TdGFfamQ0cWJxMk5iLWxORzZsbjdwMFZFblczU2xEUW5hc0N4VTVzOUc3UGY4RWczWGpHZ2RwVnJnUGN2NTRqSDJmSXBEY09VRGt5NjBFR1BjQW9DRC1Rb2p2bFpsWnZZUFgzV3ZKbi0yelEydG1IWTJoYW11VXNQUnowZFlsX1RtbXE2ZUgwODcxakRjZUdnYUp0UHVuU2ZtNkN5WHFlcUhYQkk5RjZvTVFkTnVBV1pJdzZrOWc0MTY0Y2JMTFVvSVNOM2RIclVHckdkYWpCRkFra2EyNVdWeERGSmgwYmNpWl9zVUNMMjkwU21felpSWHZZdk5ieUFoVl82dW95MkRZOGtZUnl1RWhxV0J0QTBoREg5T081MV9aeUhJYjdielhVTjkwNGdrV3lPWFcwZEhFOXhmSDVEV3RCRHM4LWN0cHQwNzJOcTFvdmp5a0FlVlhwbDZ4VVZkX1NSRFUxdEYzOHN5cGQ2LW8xdnFlempYczlQMUN6OFc5SHlGRXNSbWhLNndkM1h4aVlGNEV4ejBQR2JfdlJnX0I3QkotZlg1V3lmREpxNkE3YzNJRWRMeE43T1gyU0ZMSlc1bTFPZ2o3UVNXTmJWLWhfVlBPbXlmb05Hdk1GSnIxeTNmWmR0Tjg1ek9lLV9FTjltRlgzYnhjdVM1OVFxeFU3aXFySmVRRENNN2kzd09SWWxHRmkzeEd4Y3lsUmFiaHpWOUpUblkwTlIzTmpJSzhHT3FfcnhObHoteVREZmFzSl9TMkRmMVpJbGFPcGhPZTVBNk9iYU5HNkZpQ2RnTHdNMFVtdTJnUlBtemxoOEZxR3JGUDVpSHVIeDhCczdSY0VYWUhjeFN2alNLRjZmeWtHcGJ6dFFoTnNWdnZ2Tzgtb3ViajNWYVBTUjc4ajU2WlBnbllyYnRKTUtGbUd0blh5eGpaZXYyOWdGMFRTb3RvYWRkNEx2RXVsNnI1aGxGaERGa1gzUXIxenpVenZFcGtrd2ZRLV9rODc5MlYwUVplNkhzNDRfZjVFS2gwX0I0dnhpNUl3QVR1cWxSUzZIeVI0elE5NWN6OENFSy14a2pxb2dnTkFPMXpsYlNlaEptYmhGUG5Wa0VER3J3anp0bUZtWlY1MzM0U2dtZUMzc3JnYTIxXzBKWGFhTmJvbUdZTGxkNDcwemhDbGphUVNNOE9LX3Y1Tkg4R3dnQjlwZzZfSnVYeEx6R3B2ZHkyR2dqWHZaOXZ4LWUyc1FqSmpWa25sMGZEWjZwcFdkNVRzNGNCN0R5OVdYMlBzYVd2NEN5Q0k3elNDOGdrQUEtWDN1MTRFNEtKRHBpMFNHVXFTeWFySi05RWpqN0V0T05WYUVUNXU3QURDVERSRmlDb0M4UGU1UGl2UHJFdXNHbE5pRFpYUm8zR0hsVTFQQndsTjJzYnBfb0FYVkJiejlPWHV4UHpZRnVidlpsTzNieG1vNmxkeFM4QU9wWjVZbUdPVkoxUU4yaUg0dXJpTUpFZmlxVmwwWHBWQW9KQkVmendnS1FWR3I2a1JEMDhTZWJ2U2plb2pxcTBmZk94OE1EZmRpSWNXeWJfdDlUdnlxZWtDb2djTV9UZGxwMzJfSmlGaU5YdEcxYmJsN2pPU1QtU1pHOFNSZ2NZM1RacHFYbXdocTNKNU10amRxcFZ5ZVlwb0NrZE1heHhXUzZKLU5pNXp0TEdwRUNYSnVqak05cWItY2JzZGZPTEM2SlFjbDJBd1dKVFJpRk9NTDRXVlRMcXdzMnFaaUZkQkxBVU5Hbnc1TTlPXzJFLVA3d01oTlZGbTl0cnFrMjh6bmh2UjFRT2s0a0xWYUx1dktLUFo0NlUwd2dRLTlTeThsN1dSUWNsRGd1ZUV1azBuTHQ4b0FQV2VxY21mQV82VFRpNVNGRC1YNkhGRXp4UmRYcjZLUm01LXU4ZEhDZXlpZ2RNclhpU280VldDN0JDUDZPM094UDZBT0dfRzAxR1M0ZVo4U0lUOGFOTjd2MUNJNm1RMEZibjRfYzFoOVFzRUUxMTZpYmU0U0I4aWZZb1AxNW9HWGs4WW1PUmVHSGt0dHNUMU1rdkNJOHRyWUhtWEt4elRxTjhTZUhXRnFLUE1QeXhYWDhONVZBMmdNUm1zbkZMSWw5bWE4N1lIazJCSVdRMTlvbldMYTVhOXdRSDRGTFJQbnhHZ2tkMEtEb0JEdWpxVndBdmhYU2h6UzZ6T05KaVI1VlItNW1uV1BlbWtKbktTdUFyTW1Ic1M0ZG9Zb191S3FvRE9lRkVkM0xOLVQ3VWliaFI4Mkh0WEdEZWhjREtXYlhUQjJUeW9jbEQ5bUZ0UmhRRE9VQ1pKZE1NTkpTNmRpT084RE5DMW1QZnNqUjlXZW5zTDRnb05hb0l3NFRIWEhEVzNDVzhkbWVRYWRPVFkwcEFWM0NkQjhPTTFZM0pPWVB6aDQzb0t4XzdDNjFWQ1prcGxFUlBPWGdpLUNaZERqYWhfd29oZmY0ckRXc0lJR0c0ODJKOFNSbERzdEdRWS1TNmVtbUJ2RVRPV1VyQmZqeGN5MFBtX3Y0VkNoLWRibEdKQUs0cGlaQ19oUDN5eFM1M01YendnMkcyT2RPdlRWX3NvOWhwdGtjSlZaYk1fSE9EN2Nhc0xSbHdUN3pyYktobUZnOVhXVjRKN1RMN0Ywd0VoZzlrWF9XVWJsamRIUUViV2FpNkl5SUg1WXhjdG9KZEJLV2lJclNyV0Z2ZS1KMjVQU1VlX3BoaFd5WmtiYllxYmR4eHd3R2k1Y0NjV0RLejF4N2JCeUhWdER2aGVoc1B6N1V4eERLNGlNU2Z5QkRxVy1KQ0xaUE5kNzNpM0R0SnN4RURTeTlYS3JkUEN3SjdfMGlWSTB4WGZtTEwzejZfT0tyMkpLR09kNUtwcUl0SjJyeEhiQ3FFUkFxQ2UtWl85V0pndk5uZElDRFBWSDZQTVU2ekxuWl9FOUJVSXg4dXlLSklMbWM0SjRaV05wSEdJbndnMDRUVXlocE9KT0Y2RDFoeG5ycE9CMDZkMmVoNlJvQlE2NDNnRHRzZU1aaGxZcFZFYmdoTk9adnRzeF9UcjM1RGZlNTFXT1VkU3NwSWZaSWhOdndKU1ZOWWdNMkNkZ2RUTzBFMUVYaUJlZ1NKOVpibnU5Yi02ck1zVUYxd1VheXFBWlhLV3g4WEZOY0JLZlRKSXRDYkppUG1BdmRESzNyTkhnZzlMNG1zYk51dHJIaG83RmlVempPTS1LVVpucmxzaVVyTERSUlMxNEVvQVVucHFTLUxWTVlwbFRGY00xeVE5R291bDQxbHpqVE53Vm5qamx3akFCUGJ0ZlVHUEhBNV80ZkZhQWNVeEppLS0tcE9GME00SC1zcmd0VDFYSnFEYTdHdFNON25NMTZ4UXF0RWFaeTIyZDZ6SENtS2lyakxmczUwb1ExY1piTnFzNmlIM0t6OGhHS3pyMjg3S2stN0pBc3NwVU9XWmxWdnF1dXpPaDctNFBFbG1QcW5PeWR1TkNlWU51SXRiblZFcGFlc2Z1MzZWeWI2djNFbV9IWEdWelBYd3B3MmhVMThUaENhVVRzZzlRQU5qVXlNVzloWHJNTDB5X2prSDJSVmRZZ0NJbmg0cmliOXRGZkNHTUJVRHh5b3FEUWZrQ1N5YVVBQ0JjekRWWE1GX0pWaGE1U1lxYnhQVW1MTThhLVJ6bjBDSFpSQVpibmJwN0twZWx3WnZ3SDczcGxVSTRnZUN3ZlRrbThPUjVoSmJLa2E3bk9SS1BVaFFNVzZ5WW9Oam13NmMzR3BlMzJkVHFoLWR3QWpjajJXQ2ZJTUxGUGxzNURDcUFKOHl2Vkdqcl9jaTFqTUFFRXZ4OTAzZFNDQTBkcjFNeVRwcUd6dVQ4ZWJTVEc3S3lhdFJTYzJUNTYtMWt6MEhBWjRGSFlJeUx5YlJFWklSZ2xTcjJ3a2d4ZXhseExwZy1ya3BYRUF5VFNUQUIzNTBZeF9GQTBkdFNMdjNDZ2F1ZUxmMEVzcFB3dnhGUVJ4R096YnVIMjJ0M1ZwbWJsV1FTWHBpOGx1ZWZsOWdLNy0xUE1PaTYwZVp2SlZ6VDVmZFdwWENKQm5uY3hQTUk0ZG1EUFhGS1ZYTWNYcjEwd29WVDVEZDF0UVFTNTVfSy1YWmtxNmdObUtvMS1ldHB3azRkX1N2OWNubVpyLXFPV0hYT2t4a0kxbkJ1YnVNbTFLaTZneW4tTUttY05XbGV5X0dqaC1LMjFiYk4yb3Jmelo5T0c2cXFOLXRIcUd6ZDFkWTRjVFFjM3FldlM2MzFGX2FYdjBFSUpCUGZqSjhjYzJkOTc5RHl5a1hKUDRHZ2lTUFZRX3RZMnNQbnBiMnFPV1JfUzUzMkEzblF4c1c1VTZ3Q1BwUFNDd1lVLWNqTDdla0ZXVElXZFo2Qm1jaWgzS0ZvbVRSemhqX2hkVDlvWldIRjNjeVFHMzc2Rm9wWXhIZGZMZm1mekV6NE1mT0tMbTZjS2p0eFlrYWF3dTNNMHdScUczb1N6TFdzZkNnM2FZUEl6V05iZTZWT0IzVzcyNnc4dEtkMktSY0w2Sy1mZmI0SFNqaEFONllEYnRlT0EwV3BBS1hWcFgtTm5ReGZrN3dKWEZMR2psSTk5RHh3Q29QdjlKd1BlQ1FXLVpIaWlCUEV1NTN2bFhiaW52Yl95QjFGdkVRem5seHA2NkJaXzNndkZpbGRZa2FxeUtZZFVxdFBoc3dRQVhOOHQ1amtOdUl3cVhQUnNZWFpqUTBud3c1RFJtcXNZTHJGTkRwcUVlaEZpcXh3b2lmdW14aUJlRWg5Z2l1eG96eVRtZEplUkNLSUVzWHlBM3k0RVVwNDU2dy1JRHRfVHNWa3lCTHYxVHRLcW43RXVYcndCeGFDU2FjQzRSSk83WHR2cERlLUdQZmFzS00zdk9WckFNeW5VZGIyVEtnNkU5ME9yZEczWGRJaUNOdFAtUHB1X0VtLWNBZGYzQlBnQ29UOWlaWDdHazhQVlNUMzIwZ1JBZTNyV3BMNXRFRW8zUFZScExsSW9wVlVVRnlFb21VSmxzbC03dlNBZmpYOUxNTUMzOWxuTmYzM3ZZVkp2d2g5bHFIcGIwakJIMVg2elV5bENNWXp6NEVRam9KdGFzb25QSE1ZdVk0VEN6YU5TdlQxWEk3V2gyNXFkaGNMMzZUTjhTN1dORE1nNXg1LTlQRGFXWkl5M20yZmV2T2ozX3dTWTZiLUZyaV92ejRzeDVZcDhTZDJrdmRvUWpIem9mS3V1VGd0RWs0VUtqcnBCSmRJY3cyeFZCTUkxS3Y2c0FBXzFwWkNBTVVSYlN1R2dvQ21CRElLb2Zac0htQXpiM1lpMlp3STk3c2steE8yWTBhODJZaHp5M2podjRKTHNPc21SZmx2T2h3aWt5WHJraVA0Yk9wc0dRYWdPZUQwa0s3MUVpRGlWN3A4ekRicGRMM3BwZ2pNc0F2bXVfaG1yQ1lqRXppZEEwVmhSTXpKck1aTG1HNlpPcTc4dFFMdmlwZGowZFhFbE8weDJVZEZwVjk3cDRPTUgxVU1fUDBiNDVNUDNFa0l4NnNrTThXbGtDQTdRSWYyOVVXUUJ4eURoZ2JqWEhDaWdBbUJpU0t0OUNORDlNNGVOVDhQbFR5anNqWnVNeTAzNEM4Rm5SUjJ3Sk1mYk5SWVBTV2E5aDVwWTg3dE81SnY2SXV1a2lESnVFdE9Bd29MNE9ENkxmampRT1BmSHVMNkx0eVduZTEzcGtvbG9CZGZtRXQ1TlREc0tSZF90NHcyTFZFc0FzSC0yTU5CRjUzc3hCYmJ1WWNyWndmVEgzLWlxLUVfY2d5b2djS1M2RmVoR1hNS1FkdEwwRGN4Xy1nSkVsYlZJb19lRnllZV9aNGNkNm56TE9DUXdVX2NkOHh1NU5pQzljRVR0SkVRMkw3eHFEVXpibFhHd2IyUjFtcVpvVFhLaGNMNWtYR3AwWHBCdWNsSC1wTHJTTURxSF9kZWxhdmdXMExUMmhabkN6dU80RjJURzFKMWNmbS10ZDQyZ2xfVG5xV2FqLURpNFlNTzJBdjNxQndOdUstNzVqYWxMX3BjdnhZYmRQUFBPMmduelhSbGF0MnhrcEdRejkySlVnYlFZZFJQYlR4TllnTl9sbFJIdHlFdVlNODlNT3Z0ay1wS294S1hHYVFuZ2RqZlFkSUZBVmpUS0E2VHM2eHhfbnhZXzRhZTloVTNlYklJbmw3d1FISmNwRFZZSDlXZmU1ODYxRUVwczJESGphMkRrTXl1WGFoeEF0aWQ5QVRUZTR3N3ZYT0FIUWs1b2hvWExWQnpPRXNCcVNfQWJ4Z195RkkyVWhWVE5sQjBUOVRJY0VTeVlUM2ZFSXNXWDdOQnp2cFdDbTdSd1B2cnd3OD0="
_0x4f8e70a = "prd.py"

def print_banner():
    if colorama_available:
        colored_banner = banner.replace("CyberEncrypt", f"{Fore.GREEN}CyberEncrypt{Style.RESET_ALL}")
        print(f"{Fore.CYAN}{colored_banner}{Style.RESET_ALL}")
    else:
        print(banner)

def generate_key(password, salt):
    try:
        # Generate a key from the password using PBKDF2
        from cryptography.hazmat.primitives import hashes
        from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        return key
    except ImportError:
        print(f"{Fore.RED}Error: cryptography package not found.{Style.RESET_ALL}")
        print("Please install it with: pip install cryptography")
        sys.exit(1)

def decrypt_content(encrypted_content, key):
    try:
        # Decrypt content using Fernet
        from cryptography.fernet import Fernet
        f = Fernet(key)
        return f.decrypt(encrypted_content)
    except Exception as e:
        print(f"{Fore.RED}Decryption error: {e}{Style.RESET_ALL}")
        sys.exit(1)

def extract_files(encrypted_data, key):
    # Decrypt and extract all files
    try:
        decrypted_data = decrypt_content(encrypted_data, key)
        decompressed = zlib.decompress(decrypted_data)
        files = marshal.loads(decompressed)
        return files
    except Exception as e:
        print(f"{Fore.RED}Decryption failed: {e}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Incorrect password or corrupted data.{Style.RESET_ALL}")
        sys.exit(1)

def create_temp_dir():
    # Create a temporary directory for the decrypted files
    temp_dir = tempfile.mkdtemp(prefix="cyber_encrypt_")
    
    # Register a cleanup function to remove the temporary directory on exit
    def cleanup():
        print(f"\n{Fore.YELLOW}Cleaning up temporary files...{Style.RESET_ALL}")
        shutil.rmtree(temp_dir, ignore_errors=True)
        print(f"{Fore.GREEN}Cleanup complete.{Style.RESET_ALL}")
    
    atexit.register(cleanup)
    return temp_dir

def install_dependencies(project_dir):
    """Install dependencies from requirements.txt if it exists"""
    req_file = os.path.join(project_dir, "requirements.txt")
    if os.path.exists(req_file):
        print(f"{Fore.YELLOW}Installing dependencies from requirements.txt...{Style.RESET_ALL}")
        try:
            import subprocess
            pip_cmd = [sys.executable, "-m", "pip", "install", "-r", req_file]
            result = subprocess.run(pip_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            
            if result.returncode == 0:
                print(f"{Fore.GREEN}Dependencies installed successfully!{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}Error installing dependencies: {result.stderr}{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}Failed to install dependencies: {e}{Style.RESET_ALL}")
    else:
        print(f"{Fore.YELLOW}No requirements.txt found, skipping dependency installation{Style.RESET_ALL}")
        # Try to detect and install common packages by scanning imports
        detect_and_install_packages(project_dir)

def detect_and_install_packages(project_dir):
    """Scan Python files for imports and try to install common packages"""
    import re
    common_packages = {
        "dotenv": "python-dotenv",
        "requests": "requests",
        "bs4": "beautifulsoup4",
        "flask": "flask",
        "django": "django",
        "numpy": "numpy",
        "pandas": "pandas",
        "matplotlib": "matplotlib",
        "tensorflow": "tensorflow",
        "torch": "torch",
        "cv2": "opencv-python",
        "selenium": "selenium",
        "sqlalchemy": "sqlalchemy",
        "pymongo": "pymongo",
        "cryptography": "cryptography"
    }
    
    import_patterns = [
        re.compile(r"^\s*import\s+(\w+)"),
        re.compile(r"^\s*from\s+(\w+)"),
        re.compile(r"^\s*import\s+(\w+)\s+as"),
        re.compile(r"^\s*from\s+(\w+)\s+import")
    ]
    
    packages_to_install = set()
    
    # Walk through all Python files
    for root, _, files in os.walk(project_dir):
        for file in files:
            if file.endswith(".py"):
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                        for line in f:
                            # Check for each import pattern
                            for pattern in import_patterns:
                                match = pattern.match(line)
                                if match:
                                    package_name = match.group(1)
                                    if package_name in common_packages:
                                        packages_to_install.add(common_packages[package_name])
                except Exception:
                    # Skip files that can't be read
                    pass
    
    # Install detected packages
    if packages_to_install:
        print(f"{Fore.GREEN}Detected imports of these packages:{Style.RESET_ALL}")
        for package in packages_to_install:
            print(f"  {Fore.CYAN}- {package}{Style.RESET_ALL}")
            try:
                import subprocess
                print(f"{Fore.YELLOW}Installing {package}...{Style.RESET_ALL}")
                pip_cmd = [sys.executable, "-m", "pip", "install", package]
                result = subprocess.run(pip_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                if result.returncode == 0:
                    print(f"{Fore.GREEN} Installed {package}{Style.RESET_ALL}")
                else:
                    print(f"{Fore.RED}Error installing {package}: {result.stderr}{Style.RESET_ALL}")
            except Exception as e:
                print(f"{Fore.RED}Error installing {package}: {e}{Style.RESET_ALL}")
    else:
        print(f"{Fore.YELLOW}No common packages detected.{Style.RESET_ALL}")
def write_files(files, output_dir, key):
    # Write the decrypted files to disk with progress indicator
    total_files = len(files)
    print(f"{Fore.YELLOW}Extracting {total_files} files...{Style.RESET_ALL}")
    
    for idx, (file_path, encrypted_content) in enumerate(files.items(), 1):
        try:
            decrypted_content = decrypt_content(encrypted_content, key)
            full_path = os.path.join(output_dir, file_path)
            os.makedirs(os.path.dirname(full_path), exist_ok=True)
            
            with open(full_path, "wb") as f:
                f.write(decrypted_content)
            
            progress = int(50 * idx / total_files)
            progress_bar = "#" * progress + " " * (50-progress)
            sys.stdout.write(f"\r{Fore.CYAN}Progress: [{Fore.GREEN}{progress_bar}{Fore.CYAN}] {idx}/{total_files} files{Style.RESET_ALL}")
            sys.stdout.flush()
        except Exception as e:
            print(f"\n{Fore.RED}Error writing {file_path}: {e}{Style.RESET_ALL}")
    
    print()  # New line after progress bar
    print(f"{Fore.GREEN} Files extracted successfully!{Style.RESET_ALL}")

def run_main_file(temp_dir, main_file):
    # Run the main file of the project
    if not main_file:
        print(f"{Fore.YELLOW}No main file specified. The project has been decrypted to: {temp_dir}{Style.RESET_ALL}")
        return
    
    main_path = os.path.join(temp_dir, main_file)
    if not os.path.exists(main_path):
        print(f"{Fore.RED}Main file {main_file} not found in the decrypted project.{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Available Python files:{Style.RESET_ALL}")
        for root, _, files in os.walk(temp_dir):
            for file in files:
                if file.endswith('.py'):
                    rel_path = os.path.relpath(os.path.join(root, file), temp_dir)
                    print(f"  {Fore.CYAN}{rel_path}{Style.RESET_ALL}")
        return
    
    # Install dependencies before running
    install_dependencies(temp_dir)
    
    sys.path.insert(0, temp_dir)
    
    # Change to the directory of the main file
    original_dir = os.getcwd()
    main_dir = os.path.dirname(main_path)
    os.chdir(main_dir)
    
    print(f"{Fore.GREEN}Running {main_file}...{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}{'=' * 60}{Style.RESET_ALL}")
    
    try:
        # Load and run the main module
        spec = importlib.util.spec_from_file_location("__main__", main_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
    except Exception as e:
        print(f"\n{Fore.RED}Error running {main_file}: {e}{Style.RESET_ALL}")
    finally:
        print(f"\n{Fore.YELLOW}{'=' * 60}{Style.RESET_ALL}")
        # Restore the original directory
        os.chdir(original_dir)

if __name__ == "__main__":
    print_banner()
    
    # Parse command-line arguments
    parser = argparse.ArgumentParser(description="Run encrypted Python project")
    parser.add_argument("-p", "--password", help="Decryption password")
    args = parser.parse_args()
    
    # Get password
    password = args.password
    if not password:
        try:
            import getpass
            password = getpass.getpass(f"{Fore.CYAN}Enter decryption password: {Style.RESET_ALL}")
        except ImportError:
            password = input(f"{Fore.CYAN}Enter decryption password: {Style.RESET_ALL}")
    
    salt = base64.b64decode(_0x53a8c2b)
    key = generate_key(password, salt)
    _security_monitor = protect_runtime(key, password)
    # Disable Flask auto-reload to prevent restart issues
    os.environ["FLASK_ENV"] = "development"
    os.environ["FLASK_DEBUG"] = "0"  # Disable auto-reload
    print(f"{Fore.YELLOW}Initializing decryption...{Style.RESET_ALL}")
    encrypted_data = base64.b64decode(_0xe72fd19)
    
    # Extract files
    print(f"{Fore.YELLOW}Extracting encrypted package...{Style.RESET_ALL}")
    files = extract_files(encrypted_data, key)
    
    # Create temporary directory
    print(f"{Fore.YELLOW}Creating temporary directory...{Style.RESET_ALL}")
    temp_dir = create_temp_dir()
    
    # Write files to temporary directory
    write_files(files, temp_dir, key)
    
    print(f"{Fore.GREEN}Project decrypted successfully in secure environment{Style.RESET_ALL}")
    
    # Run the main file
    run_main_file(temp_dir, _0x4f8e70a)